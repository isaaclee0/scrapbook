{% extends "base.html" %}

{% block content %}
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div class="mb-8">
        <div class="mb-6">
            <div class="flex items-center space-x-3">
                <h1 class="text-3xl font-bold text-gray-900">{{ board.name }}</h1>
                <div class="relative">
                    <button class="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-all duration-200" onclick="toggleBoardSettings()">
                        <span class="text-lg">‚úèÔ∏è</span>
                    </button>
                    <div id="boardSettingsMenu" class="hidden absolute top-full left-0 mt-2 w-48 bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50 flex flex-col">
                        <button id="processingStatusBtn" disabled class="px-4 py-2 text-left text-sm text-gray-400 cursor-not-allowed whitespace-nowrap">
                            <span id="processingStatusText">üé® Ready</span>
                        </button>
                        <button onclick="showRenameBoardModal()" class="px-4 py-2 text-left text-sm text-gray-700 hover:bg-gray-50 transition-colors whitespace-nowrap">Rename Board</button>
                        <button onclick="showMoveBoardModal()" class="px-4 py-2 text-left text-sm text-gray-700 hover:bg-gray-50 transition-colors whitespace-nowrap">Convert to Section</button>
                        <button onclick="showDeleteBoardModal()" class="px-4 py-2 text-left text-sm text-red-600 hover:bg-red-50 transition-colors whitespace-nowrap">Delete Board</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="border-b border-gray-200">
            <nav class="flex space-x-0 overflow-x-auto">
                <button class="section-button px-4 py-3 text-sm font-medium border-b-2 border-primary-500 text-primary-600 whitespace-nowrap" data-section-id="all">All Pins</button>
                {% for section in sections %}
                <button class="section-button px-4 py-3 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap transition-colors" data-section-id="{{ section.id }}">{{ section.name }}</button>
                {% endfor %}
            </nav>
        </div>
    </div>

    <div class="flex flex-wrap justify-center gap-4" id="pinsGrid">
        {% for pin in pins %}
        <div class="pin-card bg-white rounded-xl shadow-sm hover:shadow-lg transition-all duration-300 overflow-hidden group" 
             data-section-id="{{ pin.section_id or 'all' }}" 
             {% if pin.dominant_color_1 and pin.dominant_color_2 %}
             style="--dominant-color: {{ pin.dominant_color_1 }}; --secondary-color: {{ pin.dominant_color_2 }};"
             data-colors-extracted="true"
             data-has-db-colors="true"
             {% else %}
             data-has-db-colors="false"
             {% endif %}
             data-pin-id="{{ pin.id }}"
             data-image-url="{{ pin.image_url }}"
             {% if pin.cached_filename %}
             data-cached-url="/cached/{{ pin.cached_filename }}"
             data-has-cached="true"
             {% else %}
             data-has-cached="false"
             {% endif %}>
            <a href="{{ url_for('view_pin', pin_id=pin.id) }}" class="block">
                <div class="relative overflow-hidden">
                    {% if pin.cached_filename %}
                    <img src="/cached/{{ pin.cached_filename }}" alt="{{ pin.title }}" class="w-full h-auto object-cover group-hover:scale-105 transition-transform duration-300" 
                         data-original-url="{{ pin.image_url }}">
                    {% else %}
                    <img src="{{ pin.image_url }}" alt="{{ pin.title }}" class="w-full h-auto object-cover group-hover:scale-105 transition-transform duration-300">
                    {% endif %}
                    {% if pin.section_name %}
                    <span class="absolute top-2 left-2 px-2 py-1 bg-black bg-opacity-70 text-white text-xs rounded-full">{{ pin.section_name }}</span>
                    {% endif %}
                </div>
                <div class="p-4">
                    <h3 class="font-medium text-gray-900 text-sm leading-tight mb-2 line-clamp-2">{{ pin.title }}</h3>
                    {% if pin.link %}
                    <div class="flex items-center justify-between">
                        <a href="{{ pin.link }}" target="_blank" class="text-primary-500 hover:text-primary-600 text-xs flex items-center space-x-1 transition-colors" title="Visit source" onclick="event.stopPropagation()">
                            <span>View source</span>
                            <span>‚Üó</span>
                        </a>
                    </div>
                    {% endif %}
                </div>
            </a>
        </div>
        {% endfor %}
    </div>
</div>

<!-- Board Settings Modals -->
<div class="modal" id="renameBoardModal">
    <div class="modal-content">
        <h3>Rename Board</h3>
        <input type="text" id="newBoardName" placeholder="New board name" class="board-input">
        <div class="modal-actions">
            <button class="button secondary-button" onclick="hideRenameBoardModal()">Cancel</button>
            <button class="button primary-button" onclick="renameBoard()">Rename</button>
        </div>
    </div>
</div>

<div class="modal" id="moveBoardModal">
    <div class="modal-content">
        <h3>Convert Board to Section</h3>
        <p style="margin-bottom: 15px; color: #666; font-size: 14px;">
            This will convert "{{ board.name }}" into a section within another board. 
            All pins and subsections will be moved to the selected board.
        </p>
        <select id="targetBoardSelect">
            <option value="">Select a target board...</option>
            {% for other_board in all_boards %}
            {% if other_board.id != board.id %}
            <option value="{{ other_board.id }}">{{ other_board.name }}</option>
            {% endif %}
            {% endfor %}
        </select>
        <div class="modal-actions">
            <button class="button secondary-button" onclick="hideMoveBoardModal()">Cancel</button>
            <button class="button primary-button" onclick="moveBoard()">Convert to Section</button>
        </div>
    </div>
</div>

<div class="modal" id="deleteBoardModal">
    <div class="modal-content">
        <h3>Delete Board</h3>
        <p>Are you sure you want to delete this board? This action cannot be undone.</p>
        <div class="modal-actions">
            <button class="button secondary-button" onclick="hideDeleteBoardModal()">Cancel</button>
            <button class="button delete-button" onclick="deleteBoard()">Delete</button>
        </div>
    </div>
</div>


<style>



#pinsGrid {
    padding: 20px 0;
}

.pin-card {
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: transform 0.2s, box-shadow 0.2s;
    position: relative;
    width: var(--pin-width, 250px);
    margin-bottom: 20px;
    background: white;
}

/* Default neutral appearance for pins without colors */
.pin-card:not([data-colors-extracted="true"]) {
    background: white;
    border: 1px solid #e9ecef;
}

.pin-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
}



.pin-image-container {
    position: relative;
    width: 100%;
    overflow: hidden;
    background: linear-gradient(135deg, var(--dominant-color, #f8f9fa) 0%, var(--secondary-color, #e9ecef) 100%);
    transition: background 0.5s ease;
}

/* Default neutral appearance for image containers without colors */
.pin-card:not([data-colors-extracted="true"]) .pin-image-container {
    background: #f8f9fa;
}

.pin-image {
    width: 100%;
    height: auto;
    display: block;
    transition: transform 0.2s;
}

.pin-card:hover .pin-image {
    transform: scale(1.05);
}

.pin-info {
    padding: 16px;
    position: relative;
    background: white;
}

.pin-info h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 500;
    line-height: 1.4;
    color: #333;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

.pin-card a {
    text-decoration: none;
    color: #333 !important;
    display: block;
}

.pin-card a:hover {
    color: #333 !important;
}

.source-link-icon {
    position: absolute;
    top: 16px;
    right: 16px;
    background: rgba(255,255,255,0.9);
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    text-decoration: none;
    color: #666;
    transition: all 0.2s;
}

.source-link-icon:hover {
    background: white;
    color: #007bff;
    transform: scale(1.1);
}

.section-badge {
    position: absolute;
    top: 12px;
    left: 12px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
}

/* Modal styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
}

.modal.active {
    display: block;
}

.modal-content {
    background-color: white;
    margin: 15% auto;
    padding: 20px;
    border-radius: 8px;
    width: 90%;
    max-width: 400px;
}

.modal-content h3 {
    margin-top: 0;
    margin-bottom: 20px;
}

.modal-actions {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 20px;
}

.button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
}

.primary-button {
    background-color: #007bff;
    color: white;
}

.primary-button:hover {
    background-color: #0056b3;
}

.secondary-button {
    background-color: #6c757d;
    color: white;
}

.secondary-button:hover {
    background-color: #545b62;
}

.delete-button {
    background-color: #dc3545;
    color: white;
}

.delete-button:hover {
    background-color: #c82333;
}

.board-input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.board-input:focus {
    outline: none;
    border-color: #007bff;
}

</style>

<script>
// Development mode check
const IS_DEVELOPMENT = {% if is_development %}true{% else %}false{% endif %};

// Development-only console logging
function devLog(...args) {
    if (IS_DEVELOPMENT) {
        console.log(...args);
    }
}

function devWarn(...args) {
    if (IS_DEVELOPMENT) {
        console.warn(...args);
    }
}

function devError(...args) {
    if (IS_DEVELOPMENT) {
        console.error(...args);
    }
}

// Processing state for board
let processingState = {
    phase: 'idle', // 'idle', 'caching', 'extracting', 'health-checking', 'complete'
    totalPins: 0,
    cachedPins: 0,
    extractedPins: 0,
    pinsWithLinks: 0,
    healthCheckedPins: 0,
    uncachedPins: []
};

// Board management functions
function toggleBoardSettings() {
    const menu = document.getElementById('boardSettingsMenu');
    menu.classList.toggle('hidden');
}

// Close board settings menu when clicking outside
document.addEventListener('click', (e) => {
    const menu = document.getElementById('boardSettingsMenu');
    const button = e.target.closest('button[onclick="toggleBoardSettings()"]');
    
    if (!button && !menu.contains(e.target) && !menu.classList.contains('hidden')) {
        menu.classList.add('hidden');
    }
});

function showRenameBoardModal() {
    document.getElementById('renameBoardModal').classList.add('active');
    document.getElementById('newBoardName').value = '{{ board.name }}';
    document.getElementById('newBoardName').focus();
}

function hideRenameBoardModal() {
    document.getElementById('renameBoardModal').classList.remove('active');
}

function showMoveBoardModal() {
    document.getElementById('moveBoardModal').classList.add('active');
}

function hideMoveBoardModal() {
    document.getElementById('moveBoardModal').classList.remove('active');
}

function showDeleteBoardModal() {
    document.getElementById('deleteBoardModal').classList.add('active');
}

function hideDeleteBoardModal() {
    document.getElementById('deleteBoardModal').classList.remove('active');
}

function renameBoard() {
    const newName = document.getElementById('newBoardName').value.trim();
    if (!newName) {
        alert('Please enter a board name');
        return;
    }

    fetch(`/rename-board/{{ board.id }}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: newName
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            alert('Failed to rename board');
        }
    })
    .catch(error => {
        devError('Error:', error);
        alert('Failed to rename board');
    });
}

function moveBoard() {
    const targetBoardId = document.getElementById('targetBoardSelect').value;
    if (!targetBoardId) {
        alert('Please select a target board');
        return;
    }

    fetch(`/move-board/{{ board.id }}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            target_board_id: targetBoardId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = `/board/${targetBoardId}`;
        } else {
            alert('Failed to move board');
        }
    })
    .catch(error => {
        devError('Error:', error);
        alert('Failed to move board');
    });
}

function deleteBoard() {
    fetch(`/delete-board/{{ board.id }}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = '/';
        } else {
            alert('Failed to delete board');
        }
    })
    .catch(error => {
        devError('Error:', error);
        alert('Failed to delete board');
    });
}

// Initialize the board
document.addEventListener('DOMContentLoaded', function() {
    initializeSectionFiltering();
    initializeBoardManagement();
    
    // Start automatic processing after board loads
    setTimeout(() => {
        startAutomaticProcessing();
    }, 1000);
});

// Debug function accessible from browser console
window.debugUrlHealth = function() {
    const boardId = getBoardId();
    devLog('üîç Debugging URL health for board', boardId);
    
    fetch(`/api/debug-url-health/${boardId}`)
        .then(response => response.json())
        .then(data => {
            devLog('üìä URL Health Debug Results:', data);
            
            if (data.success) {
                devLog(`\nüìã Summary:`);
                devLog(`- Board ID: ${data.board_id}`);
                devLog(`- Pins with links: ${data.stats.pins_with_links}`);
                devLog(`- Health checked: ${data.stats.health_checked_count}`);
                devLog(`- Live links: ${data.stats.live_links}`);
                devLog(`- Broken links: ${data.stats.broken_links}`);
                devLog(`- Unknown links: ${data.stats.unknown_links}`);
                devLog(`- Needs checking: ${data.needs_health_checking}`);
                
                devLog(`\nüîó URLs that would be checked:`, data.urls_that_would_be_checked);
                devLog(`\nüìå All pins with links:`, data.pins_with_links);
            }
        })
        .catch(error => {
            devError('‚ùå Debug URL health failed:', error);
        });
};

function startAutomaticProcessing() {
    devLog('üöÄ Starting automatic image processing...');
    devLog('üìä System will process in 3 phases: 1) Cache Images ‚Üí 2) Extract Colors ‚Üí 3) Check URL Health');
    
    // Count pins and their current state
    const allPins = document.querySelectorAll('.pin-card');
    const uncachedPins = Array.from(allPins).filter(pin => {
        const imageUrl = pin.getAttribute('data-image-url');
        const hasCached = pin.getAttribute('data-has-cached') === 'true';
        return imageUrl && imageUrl.startsWith('http') && !hasCached;
    });
    
    const pinsWithoutColors = Array.from(allPins).filter(pin => {
        return pin.getAttribute('data-has-db-colors') === 'false';
    });
    
    processingState.totalPins = allPins.length;
    processingState.uncachedPins = uncachedPins;
    processingState.cachedPins = allPins.length - uncachedPins.length;
    processingState.extractedPins = allPins.length - pinsWithoutColors.length;
    
    devLog(`üìä Board Analysis:`);
    devLog(`  - Total pins: ${allPins.length}`);
    devLog(`  - Uncached external images: ${uncachedPins.length}`);
    devLog(`  - Pins without colors: ${pinsWithoutColors.length}`);
    
    updateProcessingStatus();
    
    if (uncachedPins.length > 0) {
        devLog('üìÅ Phase 1: Starting image caching...');
        // Start caching phase
        processingState.phase = 'caching';
        updateProcessingStatus();
        startImageCaching(uncachedPins.length);
    } else if (pinsWithoutColors.length > 0) {
        devLog('‚úÖ Phase 1: All images already cached, skipping to phase 2...');
        devLog('üé® Phase 2: Starting color extraction...');
        // Skip to extraction phase
        processingState.phase = 'extracting';
        updateProcessingStatus();
        startColorExtraction();
    } else {
        devLog('‚úÖ Phase 1 & 2: All images cached and colors extracted, skipping to phase 3...');
        devLog('üîó Phase 3: Checking URL health...');
        // Check if we need URL health checking
        checkAndStartUrlHealthChecking();
    }
}

function startImageCaching(imageCount) {
    devLog(`üìÅ Starting to cache ${imageCount} images...`);
    
    const boardId = getBoardId();
    devLog(`üìÅ Caching images for board ${boardId}...`);
    
    fetch('/cache-images', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            limit: imageCount,
            board_id: parseInt(boardId)
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            devLog('‚úÖ Image caching started:', data.message);
            // Poll for caching completion
            pollCachingProgress();
        } else {
            devError('‚ùå Failed to start image caching:', data.error);
            processingState.phase = 'idle';
            updateProcessingStatus();
        }
    })
    .catch(error => {
        devError('‚ùå Error starting image caching:', error);
        processingState.phase = 'idle';
        updateProcessingStatus();
    });
}

function pollCachingProgress() {
    let previousCachedCount = processingState.cachedPins;
    let pollAttempts = 0;
    const maxPollAttempts = 40; // Maximum 2 minutes of polling (40 * 3 seconds)
    let noProgressCount = 0;
    const maxNoProgressCount = 10; // Stop if no progress for 30 seconds
    
    // Check caching progress every 3 seconds
    const checkProgress = () => {
        pollAttempts++;
        devLog(`üîÑ Polling caching progress... (attempt ${pollAttempts}/${maxPollAttempts})`);
        
        // Check if we've exceeded maximum polling attempts
        if (pollAttempts >= maxPollAttempts) {
            devWarn('‚è∞ Maximum polling time reached, stopping caching phase');
            devWarn('üìã Some images may have failed to cache (videos, rate limits, etc.)');
            devLog('‚úÖ Phase 1 complete: Moving to color extraction (with remaining images)');
            processingState.phase = 'extracting';
            updateProcessingStatus();
            setTimeout(startColorExtraction, 2000);
            return;
        }
        
        // Check if we have new cached images by making a quick API call
        fetch(`/api/board-status/${getBoardId()}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    devLog(`üìä Caching status: ${data.cached_count}/${processingState.totalPins} images cached`);
                    
                    // Update cached pins in the DOM
                    if (data.cached_pins && data.cached_pins.length > 0) {
                        devLog(`üì• Updating ${data.cached_pins.length} newly cached pins in DOM`);
                        updateCachedPinsInDOM(data.cached_pins);
                    }
                    
                    // Update extracted pins in the DOM
                    if (data.extracted_pins && data.extracted_pins.length > 0) {
                        devLog(`üé® Updating ${data.extracted_pins.length} newly color-extracted pins in DOM`);
                        updateExtractedPinsInDOM(data.extracted_pins);
                    }
                    
                    // Check for progress
                    if (data.cached_count > previousCachedCount) {
                        const newlyCached = data.cached_count - previousCachedCount;
                        devLog(`üìÅ +${newlyCached} images cached (${data.cached_count}/${processingState.totalPins} total)`);
                        previousCachedCount = data.cached_count;
                        noProgressCount = 0; // Reset no progress counter
                    } else {
                        noProgressCount++;
                        devLog(`üìã No new images cached (${noProgressCount}/${maxNoProgressCount} attempts without progress)`);
                    }
                    
                    // Update processing state counts
                    processingState.cachedPins = data.cached_count;
                    processingState.extractedPins = data.extracted_count;
                    updateProcessingStatus();
                    
                    // Check if all external images are cached by counting current DOM state
                    const allPins = document.querySelectorAll('.pin-card');
                    const uncachedExternalPins = Array.from(allPins).filter(pin => {
                        const imageUrl = pin.getAttribute('data-image-url');
                        const hasCached = pin.getAttribute('data-has-cached') === 'true';
                        return imageUrl && imageUrl.startsWith('http') && !hasCached;
                    });
                    
                    devLog(`üìã Remaining uncached external images: ${uncachedExternalPins.length}`);
                    
                    if (uncachedExternalPins.length <= 0) {
                        devLog('üéâ All external images have been cached!');
                        devLog('‚úÖ Phase 1 complete: Image caching finished');
                        devLog('üé® Phase 2: Starting color extraction...');
                        processingState.phase = 'extracting';
                        updateProcessingStatus();
                        // Wait a moment then start color extraction
                        setTimeout(startColorExtraction, 2000);
                    } else if (noProgressCount >= maxNoProgressCount) {
                        devWarn(`‚è∞ No progress for ${maxNoProgressCount * 3} seconds, moving to next phase`);
                        devWarn(`üìã ${uncachedExternalPins.length} images couldn't be cached (likely videos or rate-limited)`);
                        devLog('‚úÖ Phase 1 complete: Moving to color extraction (with remaining images)');
                        processingState.phase = 'extracting';
                        updateProcessingStatus();
                        setTimeout(startColorExtraction, 2000);
                    } else {
                        devLog(`‚è≥ Still waiting for ${uncachedExternalPins.length} images, will check again in 3 seconds...`);
                        // Continue polling
                        setTimeout(checkProgress, 3000);
                    }
                } else {
                    devWarn('‚ö†Ô∏è API returned error:', data);
                    // Continue polling but count as no progress
                    noProgressCount++;
                    if (noProgressCount >= maxNoProgressCount) {
                        devWarn('‚ö†Ô∏è Too many API errors, moving to next phase');
                        processingState.phase = 'extracting';
                        updateProcessingStatus();
                        setTimeout(startColorExtraction, 2000);
                    } else {
                        setTimeout(checkProgress, 5000);
                    }
                }
            })
            .catch(error => {
                devWarn('‚ùå Error checking caching progress:', error);
                noProgressCount++;
                if (noProgressCount >= maxNoProgressCount) {
                    devWarn('‚ùå Too many network errors, moving to next phase');
                    processingState.phase = 'extracting';
                    updateProcessingStatus();
                    setTimeout(startColorExtraction, 2000);
                } else {
                    // Continue polling anyway
                    setTimeout(checkProgress, 5000);
                }
            });
    };
    
    // Start polling
    devLog('‚è≥ Starting to poll for caching progress every 3 seconds...');
    devLog('üìã Will automatically move to next phase if no progress or after 2 minutes');
    setTimeout(checkProgress, 3000);
}

function updateCachedPinsInDOM(cachedPins) {
    cachedPins.forEach(cachedPin => {
        const pinElement = document.querySelector(`[data-pin-id="${cachedPin.id}"]`);
        if (pinElement) {
            const currentHasCached = pinElement.getAttribute('data-has-cached') === 'true';
            
            if (!currentHasCached) {
                // Update the pin element to show it's now cached
                pinElement.setAttribute('data-has-cached', 'true');
                pinElement.setAttribute('data-cached-url', `/cached/${cachedPin.cached_filename}`);
                
                // Update the image source to use the cached version
                const imgElement = pinElement.querySelector('.pin-image');
                if (imgElement) {
                    const originalSrc = imgElement.src;
                    imgElement.src = `/cached/${cachedPin.cached_filename}`;
                    imgElement.setAttribute('data-original-url', originalSrc);
                    
                    // Add a subtle flash effect to show the image was updated
                    imgElement.style.transition = 'opacity 0.3s ease';
                    imgElement.style.opacity = '0.7';
                    setTimeout(() => {
                        imgElement.style.opacity = '1';
                    }, 150);
                }
                
                devLog(`‚úÖ Updated pin ${cachedPin.id} to use cached image: ${cachedPin.cached_filename}`);
            }
        }
    });
}

function updateExtractedPinsInDOM(extractedPins) {
    extractedPins.forEach(extractedPin => {
        const pinElement = document.querySelector(`[data-pin-id="${extractedPin.id}"]`);
        if (pinElement) {
            const currentHasColors = pinElement.getAttribute('data-has-db-colors') === 'true';
            
            if (!currentHasColors && extractedPin.color1 && extractedPin.color2) {
                // Update the pin element to show colors are extracted
                pinElement.setAttribute('data-has-db-colors', 'true');
                pinElement.setAttribute('data-colors-extracted', 'true');
                
                // Apply the colors to the pin
                pinElement.style.setProperty('--dominant-color', extractedPin.color1);
                pinElement.style.setProperty('--secondary-color', extractedPin.color2);
                
                devLog(`‚úÖ Updated pin ${extractedPin.id} with extracted colors: ${extractedPin.color1}, ${extractedPin.color2}`);
            }
        }
    });
}

function startColorExtraction() {
    devLog('üé® Starting color extraction phase...');
    
    // Get all pins that need color extraction (refresh from current DOM state)
    const pinsNeedingColors = document.querySelectorAll('.pin-card[data-has-db-colors="false"]');
    
    devLog(`üìä Found ${pinsNeedingColors.length} pins that need color extraction`);
    
    if (pinsNeedingColors.length === 0) {
        devLog('‚úÖ No pins need color extraction, phase 2 complete');
        devLog('üîó Phase 3: Starting URL health checking...');
        checkAndStartUrlHealthChecking();
        return;
    }
    
    let processed = 0;
    const total = pinsNeedingColors.length;
    
    const processNextPin = () => {
        if (processed >= total) {
            devLog('üéâ Color extraction phase complete!');
            devLog('‚úÖ Phase 2 complete: Color extraction finished');
            devLog('üîó Phase 3: Starting URL health checking...');
            // Move to URL health checking phase
            checkAndStartUrlHealthChecking();
            return;
        }
        
        const pin = pinsNeedingColors[processed];
        const pinId = pin.getAttribute('data-pin-id');
        const pinTitle = pin.querySelector('h3')?.textContent || `Pin ${pinId}`;
        
        devLog(`üé® Processing pin ${processed + 1}/${total}: "${pinTitle}" (ID: ${pinId})`);
        
        const img = pin.querySelector('.pin-image');
        
        if (img) {
            extractColorsFromPin(pin, img, (success) => {
                processed++;
                processingState.extractedPins++;
                
                if (success) {
                    devLog(`‚úÖ Colors extracted for pin ${pinId} (${processed}/${total})`);
                } else {
                    devLog(`‚ö†Ô∏è Color extraction failed for pin ${pinId} (${processed}/${total})`);
                }
                
                updateProcessingStatus();
                
                // Show progress every 10 pins or at completion
                if (processed % 10 === 0 || processed === total) {
                    devLog(`üìä Color extraction progress: ${processed}/${total} pins completed`);
                }
                
                // Continue with next pin after a short delay
                setTimeout(processNextPin, 500);
            });
        } else {
            devLog(`‚ö†Ô∏è No image found for pin ${pinId}, skipping...`);
            processed++;
            setTimeout(processNextPin, 100);
        }
    };
    
    devLog('üé® Starting to process pins for color extraction...');
    processNextPin();
}

function extractColorsFromPin(pinCard, img, callback) {
    try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 50;
        canvas.height = 50;
        
        // Use cached image if available
        const hasCachedImage = pinCard.getAttribute('data-has-cached') === 'true';
        const imageUrl = hasCachedImage ? pinCard.getAttribute('data-cached-url') : img.src;
        
        const tempImg = new Image();
        if (!hasCachedImage) {
            tempImg.crossOrigin = 'anonymous';
        }
        
        tempImg.onload = function() {
            try {
                ctx.drawImage(tempImg, 0, 0, 50, 50);
                const colors = extractDominantColorsFromCanvas(canvas);
                
                // Apply colors to the image container
                pinCard.style.setProperty('--dominant-color', colors.primary);
                pinCard.style.setProperty('--secondary-color', colors.secondary);
                pinCard.setAttribute('data-colors-extracted', 'true');
                pinCard.setAttribute('data-has-db-colors', 'true');
                
                // Save to database
                const pinId = pinCard.getAttribute('data-pin-id');
                if (pinId) {
                    saveColorsToDatabase(pinId, colors.primary, colors.secondary);
                }
                
                callback(true); // Success
            } catch (e) {
                devWarn('Could not extract colors from image:', imageUrl, e);
                callback(false); // Failed
            }
        };
        
        tempImg.onerror = function() {
            devWarn('Image failed to load:', imageUrl);
            callback(false); // Failed
        };
        
        tempImg.src = imageUrl;
        
    } catch (e) {
        devWarn('Error processing image:', e);
        callback(false); // Failed
    }
}

function extractDominantColorsFromCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    const colorMap = new Map();
    
    for (let i = 0; i < data.length; i += 4) {
        const r = Math.round(data[i] / 32) * 32;
        const g = Math.round(data[i + 1] / 32) * 32;
        const b = Math.round(data[i + 2] / 32) * 32;
        const alpha = data[i + 3];
        
        if (alpha < 128) continue;
        
        const colorKey = `${r},${g},${b}`;
        colorMap.set(colorKey, (colorMap.get(colorKey) || 0) + 1);
    }
    
    const sortedColors = Array.from(colorMap.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2);
    
    if (sortedColors.length === 0) {
        return { primary: '#f0f0f0', secondary: '#e0e0e0' };
    }
    
    const primaryRgb = sortedColors[0][0].split(',').map(Number);
    const primary = `rgb(${primaryRgb[0]}, ${primaryRgb[1]}, ${primaryRgb[2]})`;
    
    let secondary;
    if (sortedColors.length > 1) {
        const secondaryRgb = sortedColors[1][0].split(',').map(Number);
        secondary = `rgb(${secondaryRgb[0]}, ${secondaryRgb[1]}, ${secondaryRgb[2]})`;
    } else {
        const lighter = primaryRgb.map(c => Math.min(255, c + 30));
        secondary = `rgb(${lighter[0]}, ${lighter[1]}, ${lighter[2]})`;
    }
    
    return { primary, secondary };
}

function saveColorsToDatabase(pinId, color1, color2) {
    fetch(`/save-pin-colors/${pinId}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            dominant_color_1: color1,
            dominant_color_2: color2
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            devLog(`‚úÖ Saved colors for pin ${pinId}`);
        } else {
            devWarn(`‚ö†Ô∏è Failed to save colors for pin ${pinId}:`, data.error);
        }
    })
    .catch(error => {
        devWarn(`‚ö†Ô∏è Error saving colors for pin ${pinId}:`, error);
    });
}

function checkAndStartUrlHealthChecking() {
    // Get current board status to see if URL health checking is needed
    devLog('üîç Checking if URL health checking is needed...');
    
    fetch(`/api/board-status/${getBoardId()}`)
        .then(response => response.json())
        .then(data => {
            devLog('üìä Board status for URL health:', data);
            
            if (data.success) {
                processingState.pinsWithLinks = data.pins_with_links;
                processingState.healthCheckedPins = data.health_checked_count;
                
                devLog(`üìã URL Health Summary:`);
                devLog(`  - Pins with links: ${data.pins_with_links}`);
                devLog(`  - Health checked: ${data.health_checked_count}`);
                devLog(`  - Live links: ${data.live_links}`);
                devLog(`  - Broken links: ${data.broken_links}`);
                devLog(`  - Archived links: ${data.archived_links}`);
                
                const needsChecking = data.pins_with_links - data.health_checked_count;
                
                if (needsChecking > 0) {
                    devLog(`üîó ${needsChecking} URLs need health checking, starting URL health phase...`);
                    // Start URL health checking phase
                    processingState.phase = 'health-checking';
                    updateProcessingStatus();
                    startUrlHealthChecking();
                } else {
                    devLog('‚úÖ All URLs already health checked!');
                    devLog('üéâ All processing phases complete! System is ready.');
                    // Everything is complete
                    processingState.phase = 'complete';
                    updateProcessingStatus();
                }
            } else {
                devWarn('‚ö†Ô∏è Board status API failed:', data);
                devWarn('‚ö†Ô∏è Marking processing as complete due to API failure');
                // If API fails, just mark as complete
                processingState.phase = 'complete';
                updateProcessingStatus();
            }
        })
        .catch(error => {
            devWarn('‚ùå Error checking URL health status:', error);
            devWarn('‚ùå Marking processing as complete due to network error');
            processingState.phase = 'complete';
            updateProcessingStatus();
        });
}

function startUrlHealthChecking() {
    devLog('üîó Starting URL health checking phase...');
    
    const uncheckedUrls = processingState.pinsWithLinks - processingState.healthCheckedPins;
    const batchSize = Math.min(uncheckedUrls, 20);
    
    devLog(`üìä URL Health Status:`);
    devLog(`  - Total pins with links: ${processingState.pinsWithLinks}`);
    devLog(`  - Already checked: ${processingState.healthCheckedPins}`);
    devLog(`  - Remaining to check: ${uncheckedUrls}`);
    devLog(`  - Checking batch size: ${batchSize}`);
    
    fetch(`/api/check-url-health/${getBoardId()}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            limit: batchSize
        })
    })
    .then(response => {
        devLog('üåê URL health check API response received');
        return response.json();
    })
    .then(data => {
        devLog('üîó URL health check response:', data);
        
        if (data.success) {
            devLog(`‚úÖ URL health check batch complete: ${data.message}`);
            devLog(`üìä Checked ${data.checked} URLs in this batch`);
            
            // Show detailed results if available
            if (data.results && data.results.length > 0) {
                devLog('üìã Detailed results:');
                data.results.forEach((result, index) => {
                    const statusEmoji = result.status === 'live' ? 'üü¢' : result.status === 'broken' ? 'üî¥' : 'üü£';
                    devLog(`  ${index + 1}. ${statusEmoji} Pin ${result.pin_id}: ${result.status} (${result.url})`);
                });
            }
            
            processingState.healthCheckedPins += data.checked;
            
            const totalChecked = processingState.healthCheckedPins;
            const totalWithLinks = processingState.pinsWithLinks;
            const remainingUrls = totalWithLinks - totalChecked;
            
            devLog(`üìä Overall Progress: ${totalChecked}/${totalWithLinks} URLs checked`);
            
            if (remainingUrls <= 0) {
                // All URLs checked
                devLog('üéâ All URLs have been health checked!');
                devLog('‚úÖ Phase 3 complete: URL health checking finished');
                devLog('üéâ All processing phases complete! System is ready.');
                processingState.phase = 'complete';
                updateProcessingStatus();
            } else {
                // Continue checking more URLs
                devLog(`‚è≥ ${remainingUrls} URLs still need checking...`);
                devLog(`‚è≥ Continuing URL health checking in 3 seconds...`);
                setTimeout(startUrlHealthChecking, 3000);
            }
        } else {
            devError('‚ùå URL health check batch failed:', data.error);
            devError('‚ùå Stopping URL health checking due to error');
            processingState.phase = 'complete';
            updateProcessingStatus();
        }
    })
    .catch(error => {
        devError('‚ùå Network error during URL health checking:', error);
        devError('‚ùå Stopping URL health checking due to network error');
        processingState.phase = 'complete';
        updateProcessingStatus();
    });
}

function updateProcessingStatus() {
    const statusBtn = document.getElementById('processingStatusBtn');
    const statusText = document.getElementById('processingStatusText');
    
    switch (processingState.phase) {
        case 'idle':
            statusText.textContent = 'üé® Ready';
            break;
        case 'caching':
            // Count uncached pins dynamically from DOM
            const allPins = document.querySelectorAll('.pin-card');
            const uncachedPins = Array.from(allPins).filter(pin => {
                const imageUrl = pin.getAttribute('data-image-url');
                const hasCached = pin.getAttribute('data-has-cached') === 'true';
                return imageUrl && imageUrl.startsWith('http') && !hasCached;
            });
            const uncachedCount = uncachedPins.length;
            statusText.textContent = `üìÅ Caching ${uncachedCount} images...`;
            break;
        case 'extracting':
            // Count pins without colors dynamically from DOM
            const pinsWithoutColors = document.querySelectorAll('.pin-card[data-has-db-colors="false"]');
            const remaining = pinsWithoutColors.length;
            statusText.textContent = `üé® Extracting colors (${remaining} left)`;
            break;
        case 'health-checking':
            const uncheckedUrls = processingState.pinsWithLinks - processingState.healthCheckedPins;
            statusText.textContent = `üîó Checking ${uncheckedUrls} URLs...`;
            break;
        case 'complete':
            statusText.textContent = `‚úÖ All processing complete`;
            break;
    }
}

function getBoardId() {
    // Extract board ID from URL or data attribute
    const path = window.location.pathname;
    const match = path.match(/\/board\/(\d+)/);
    return match ? match[1] : null;
}


// Section button handling
function initializeSectionFiltering() {
    const sectionButtons = document.querySelectorAll('.section-button');
    sectionButtons.forEach(button => {
        button.addEventListener('click', function() {
            sectionButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            
            const selectedSection = this.dataset.sectionId;
            const items = document.querySelectorAll('.pin-card');
            
            items.forEach(item => {
                if (selectedSection === 'all' || item.dataset.sectionId === selectedSection) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        });
    });
}

// Board management buttons
function initializeBoardManagement() {
    // No special initialization needed for the new automatic system
}

</script>
{% endblock %} 