{% extends "base.html" %}

{% block content %}
<script>
// Define this function immediately so inline onload handlers can use it
// Simplified: Calculate container height when image loads, based on actual image dimensions
function correctImageContainerHeight(imgElement) {
    if (!imgElement || !imgElement.naturalWidth || !imgElement.naturalHeight) {
        return;
    }
    
    const imageContainer = imgElement.closest('.image-container');
    if (!imageContainer) {
        return;
    }
    
    // Check if height was pre-reserved
    const heightSource = imageContainer.getAttribute('data-height-source');
    const isHeightLocked = imageContainer.hasAttribute('data-height-locked');
    
    if (isHeightLocked) {
        const currentHeight = parseInt(imageContainer.style.height);
        
        // If height came from cached dimensions, keep it locked (most accurate)
        // If height was estimated, we can update it with the real dimensions
        if (heightSource === 'cached' && currentHeight && currentHeight > 0) {
            // Just ensure image fits the container, don't recalculate height
            imgElement.style.setProperty('height', currentHeight + 'px', 'important');
            imgElement.style.setProperty('max-height', currentHeight + 'px', 'important');
            imgElement.style.setProperty('width', '100%', 'important');
            imgElement.style.setProperty('object-fit', 'cover', 'important');
            imgElement.style.setProperty('display', 'block', 'important');
            imgElement.style.setProperty('position', 'absolute', 'important');
            imgElement.style.setProperty('top', '0', 'important');
            imgElement.style.setProperty('left', '0', 'important');
            return;
        }
        // For estimated heights, we'll recalculate below but keep the locked state
    }
    
    // Wait for container to have width - use getBoundingClientRect for masonry grid
    const tryCorrect = (attempt = 0) => {
        // In masonry grids, use getBoundingClientRect for accurate width
        const containerRect = imageContainer.getBoundingClientRect();
        let containerWidth = containerRect.width;
        
        // Fallback methods if getBoundingClientRect doesn't work
        if (!containerWidth || containerWidth === 0) {
            containerWidth = imageContainer.offsetWidth || 
                            imageContainer.clientWidth ||
                            parseFloat(window.getComputedStyle(imageContainer).width);
        }
        
        // Try parent element (pin-card) width as fallback
        if ((!containerWidth || containerWidth === 0) && imageContainer.parentElement) {
            const parentRect = imageContainer.parentElement.getBoundingClientRect();
            containerWidth = parentRect.width || 
                           imageContainer.parentElement.offsetWidth ||
                           parseFloat(window.getComputedStyle(imageContainer.parentElement).width);
        }
        
        // If still no width, wait for layout to settle
        if (!containerWidth || containerWidth === 0 || isNaN(containerWidth)) {
            if (attempt < 30) { // More retries for masonry layout
                setTimeout(() => tryCorrect(attempt + 1), 50);
                return;
            }
            // Last resort: calculate from CSS variable or use default
            const pinWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--pin-width')) || 300;
            containerWidth = pinWidth - 32; // Account for padding/margins
        }
        
        // Validate dimensions exist
        if (!imgElement.naturalWidth || !imgElement.naturalHeight) {
            return;
        }
        
        const naturalWidth = imgElement.naturalWidth;
        const naturalHeight = imgElement.naturalHeight;
        
        // Calculate aspect ratio and cap at 2:1 (height:width), but also cap absolute height at 500px
        const rawAspectRatio = naturalHeight / naturalWidth;
        const maxAspectRatio = 2;
        const aspectRatio = Math.min(rawAspectRatio, maxAspectRatio);
        
        // Calculate height based on container width and capped aspect ratio
        let calculatedHeight = containerWidth * aspectRatio;
        
        // Cap the absolute height at 500px to prevent overly tall images
        const maxAbsoluteHeight = 500;
        calculatedHeight = Math.min(calculatedHeight, maxAbsoluteHeight);
        
        // Ensure minimum height
        const finalHeight = Math.max(150, Math.round(calculatedHeight));
        
        // Set container height - use !important to override any CSS max-height
        // First, explicitly remove any existing max-height
        imageContainer.style.removeProperty('max-height');
        // Then set all height properties with !important
        imageContainer.style.setProperty('height', finalHeight + 'px', 'important');
        imageContainer.style.setProperty('min-height', finalHeight + 'px', 'important');
        imageContainer.style.setProperty('max-height', finalHeight + 'px', 'important');
        imageContainer.style.setProperty('padding-bottom', '0', 'important');
        // Also set inline style without !important as backup
        imageContainer.style.height = finalHeight + 'px';
        imageContainer.style.maxHeight = finalHeight + 'px';
        // Lock height to prevent recalculation during image swap
        imageContainer.setAttribute('data-height-locked', 'true');
        
        // Ensure image fills the container completely - match container exactly
        imgElement.style.setProperty('height', finalHeight + 'px', 'important');
        imgElement.style.setProperty('max-height', finalHeight + 'px', 'important');
        imgElement.style.setProperty('width', '100%', 'important');
        imgElement.style.setProperty('max-width', '100%', 'important');
        imgElement.style.setProperty('object-fit', 'cover', 'important');
        imgElement.style.setProperty('display', 'block', 'important');
        imgElement.style.setProperty('position', 'absolute', 'important');
        imgElement.style.setProperty('top', '0', 'important');
        imgElement.style.setProperty('left', '0', 'important');
        imgElement.style.setProperty('margin', '0', 'important');
        imgElement.style.setProperty('padding', '0', 'important');
    };
    
    // Small delay to ensure layout has settled
    setTimeout(() => tryCorrect(), 10);
}

// Estimate container width based on viewport
function estimateContainerWidth() {
    const viewportWidth = window.innerWidth;
    let columnCount = 5; // default
    if (viewportWidth <= 500) columnCount = 1;
    else if (viewportWidth <= 800) columnCount = 2;
    else if (viewportWidth <= 1200) columnCount = 3;
    else if (viewportWidth <= 1600) columnCount = 4;
    
    // Check for custom column count from pin size setting
    const pinsGrid = document.getElementById('pinsGrid');
    if (pinsGrid && pinsGrid.style.columnCount) {
        columnCount = parseInt(pinsGrid.style.columnCount) || columnCount;
    }
    
    const gridPadding = 40; // 20px on each side
    const columnGap = 16;
    const availableWidth = Math.min(viewportWidth, 1280) - gridPadding;
    return (availableWidth - (columnGap * (columnCount - 1))) / columnCount;
}

// Pre-reserve space for images based on stored dimensions (runs BEFORE images load)
// This prevents layout shifts when navigating to a specific pin
function preReserveImageSpace(pinCard, useDefaultAspectRatio = false) {
    const cachedWidth = parseInt(pinCard.getAttribute('data-cached-width'));
    const cachedHeight = parseInt(pinCard.getAttribute('data-cached-height'));
    
    const hasDimensions = cachedWidth && cachedHeight && !isNaN(cachedWidth) && !isNaN(cachedHeight);
    
    // If no dimensions and not using default, skip
    if (!hasDimensions && !useDefaultAspectRatio) {
        return false;
    }
    
    const imageContainer = pinCard.querySelector('.image-container');
    if (!imageContainer) {
        return false;
    }
    
    // Skip if already locked
    if (imageContainer.hasAttribute('data-height-locked')) {
        return true;
    }
    
    // Get container width - for masonry, use pin card width
    let containerWidth = pinCard.offsetWidth || pinCard.clientWidth;
    
    // If container has no width yet (not rendered), estimate based on column layout
    if (!containerWidth || containerWidth === 0) {
        containerWidth = estimateContainerWidth();
    }
    
    let aspectRatio;
    if (hasDimensions) {
        // Calculate aspect ratio and cap at 2:1 (height:width)
        const rawAspectRatio = cachedHeight / cachedWidth;
        const maxAspectRatio = 2;
        aspectRatio = Math.min(rawAspectRatio, maxAspectRatio);
    } else {
        // Use default 4:3 aspect ratio for pins without dimensions
        aspectRatio = 0.75; // 3/4 = 0.75 (landscape orientation, common for web images)
    }
    
    // Calculate height based on container width and aspect ratio
    let calculatedHeight = containerWidth * aspectRatio;
    
    // Cap the absolute height at 500px
    const maxAbsoluteHeight = 500;
    calculatedHeight = Math.min(calculatedHeight, maxAbsoluteHeight);
    
    // Ensure minimum height
    const finalHeight = Math.max(150, Math.round(calculatedHeight));
    
    // Set container height immediately and lock it
    imageContainer.style.setProperty('height', finalHeight + 'px', 'important');
    imageContainer.style.setProperty('min-height', finalHeight + 'px', 'important');
    imageContainer.style.setProperty('max-height', finalHeight + 'px', 'important');
    imageContainer.setAttribute('data-height-locked', 'true');
    
    // Mark whether this was a real dimension or estimate
    imageContainer.setAttribute('data-height-source', hasDimensions ? 'cached' : 'estimated');
    
    return true;
}

// Pre-reserve space for ALL pin cards on page load
function preReserveAllImageSpaces() {
    const pinsGrid = document.getElementById('pinsGrid');
    
    // Add loading class to disable transitions during layout
    if (pinsGrid) {
        pinsGrid.classList.add('loading-layout');
    }
    
    // First, reserve space for pins WITH cached dimensions
    const pinsWithDimensions = document.querySelectorAll('.pin-card[data-cached-width][data-cached-height]');
    let reservedWithDimensions = 0;
    
    pinsWithDimensions.forEach(pinCard => {
        const w = pinCard.getAttribute('data-cached-width');
        const h = pinCard.getAttribute('data-cached-height');
        // Only count if dimensions are actually present (not empty strings)
        if (w && h && w !== '' && h !== '') {
            if (preReserveImageSpace(pinCard, false)) {
                reservedWithDimensions++;
            }
        }
    });
    
    // Then, reserve space for pins WITHOUT dimensions using default aspect ratio
    const allPinCards = document.querySelectorAll('.pin-card');
    let reservedWithDefault = 0;
    
    allPinCards.forEach(pinCard => {
        const container = pinCard.querySelector('.image-container');
        // Skip if already locked
        if (container && !container.hasAttribute('data-height-locked')) {
            if (preReserveImageSpace(pinCard, true)) {
                reservedWithDefault++;
            }
        }
    });
    
    console.log(`Pre-reserved space: ${reservedWithDimensions} with cached dimensions, ${reservedWithDefault} with default aspect ratio`);
    
    // Remove loading class after a short delay to allow layout to stabilize
    // Then re-enable transitions for normal interactions
    setTimeout(() => {
        if (pinsGrid) {
            pinsGrid.classList.remove('loading-layout');
            console.log('Layout stabilized, transitions re-enabled');
        }
    }, 500);
}

// Run pre-reservation as soon as possible (before images start loading)
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', preReserveAllImageSpaces);
} else {
    // DOM already loaded, run immediately
    preReserveAllImageSpaces();
}
</script>
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <div class="mb-8">
        <div class="mb-6">
            <div class="flex items-center space-x-3">
                <h1 class="text-3xl font-bold text-gray-900">{{ board.name }}</h1>
                <div class="relative">
                    <button class="p-2 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg transition-all duration-200" onclick="toggleBoardSettings()">
                        <span class="text-lg">‚úèÔ∏è</span>
                    </button>
                    <div id="boardSettingsMenu" class="hidden absolute top-full left-0 mt-2 w-48 bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50 flex flex-col">
                        <button id="processingStatusBtn" disabled class="px-4 py-2 text-left text-sm text-gray-400 cursor-not-allowed whitespace-nowrap">
                            <span id="processingStatusText">üé® Ready</span>
                        </button>
                        <button onclick="showRenameBoardModal()" class="px-4 py-2 text-left text-sm text-gray-700 hover:bg-gray-50 transition-colors whitespace-nowrap">Rename Board</button>
                        <button onclick="showMoveBoardModal()" class="px-4 py-2 text-left text-sm text-gray-700 hover:bg-gray-50 transition-colors whitespace-nowrap">Convert to Section</button>
                        <button onclick="showDeleteBoardModal()" class="px-4 py-2 text-left text-sm text-red-600 hover:bg-red-50 transition-colors whitespace-nowrap">Delete Board</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Section Circles -->
        <div class="section-circles-container">
            <div class="section-circles-scroll">
                <button class="section-circle active" data-section-id="all" title="All Pins">
                    <div class="section-circle-image-wrapper">
                        <div class="section-circle-image all-pins-circle">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                            </svg>
                        </div>
                    </div>
                    <span class="section-circle-name">All</span>
                </button>
                {% for section in sections %}
                <button class="section-circle{% if section.pin_count == 0 %} empty-section{% endif %}" data-section-id="{{ section.id }}" title="{{ section.name }} ({{ section.pin_count }} pins)">
                    <div class="section-circle-image-wrapper">
                        <div class="section-circle-image">
                            {% if section.default_image_url %}
                            <img src="{{ section.default_image_url }}" 
                                 alt="{{ section.name }}" 
                                 loading="lazy"
                                 onerror="this.src='/static/images/default_pin.png'">
                            {% else %}
                            <img src="/static/images/default_pin.png" alt="{{ section.name }}">
                            {% endif %}
                        </div>
                        {% if section.pin_count > 0 %}
                        <span class="section-pin-count">{{ section.pin_count }}</span>
                        {% endif %}
                    </div>
                    <span class="section-circle-name">{{ section.name }}{% if section.pin_count == 0 %} <span class="text-gray-400 text-xs">(empty)</span>{% endif %}</span>
                </button>
                {% endfor %}
            </div>
        </div>
    </div>

    <div class="masonry-grid loading-layout" id="pinsGrid">
        {% for pin in pins %}
        <div class="pin-card bg-white rounded-xl shadow-sm hover:shadow-lg transition-all duration-300 overflow-hidden group" 
             data-section-id="{{ pin.section_id or 'all' }}" 
             {% if pin.dominant_color_1 and pin.dominant_color_2 %}
             style="--dominant-color: {{ pin.dominant_color_1 }}; --secondary-color: {{ pin.dominant_color_2 }};"
             data-colors-extracted="true"
             data-has-db-colors="true"
             {% else %}
             data-has-db-colors="false"
             {% endif %}
             data-pin-id="{{ pin.id }}"
             id="pin-{{ pin.id }}"
             data-cached-width="{{ pin.cached_width or '' }}"
             data-cached-height="{{ pin.cached_height or '' }}"
             {% if pin.cached_filename %}
             data-cached-url="/cached/{{ pin.cached_filename }}"
             data-has-cached="true"
             {% else %}
             data-has-cached="false"
             {% endif %}>
            <a href="{{ url_for('view_pin', pin_id=pin.id) }}" class="block">
                <div class="relative overflow-hidden image-container">
                    <!-- Skeleton loader that shows before image loads -->
                    <div class="skeleton-loader"></div>
                    {% if pin.cached_filename %}
                    <img src="/cached/{{ pin.cached_filename }}" 
                         alt="{{ pin.title }}" 
                         class="pin-image group-hover:scale-105 transition-transform duration-300" 
                         loading="eager"
                         data-original-url="{{ pin.image_url }}"
                         onload="this.classList.add('loaded'); this.previousElementSibling.style.display='none'; correctImageContainerHeight(this);"
                         onerror="this.src='/static/images/default_pin.png'; this.classList.add('loaded'); this.previousElementSibling.style.display='none';">
                    {% else %}
                    <img src="{{ pin.image_url }}" 
                         alt="{{ pin.title }}" 
                         class="pin-image group-hover:scale-105 transition-transform duration-300"
                         loading="eager"
                         onload="this.classList.add('loaded'); this.previousElementSibling.style.display='none'; correctImageContainerHeight(this);"
                         onerror="this.src='/static/images/default_pin.png'; this.classList.add('loaded'); this.previousElementSibling.style.display='none';">
                    {% endif %}
                    {% if pin.section_name %}
                    <span class="absolute top-2 left-2 px-2 py-1 bg-black bg-opacity-70 text-white text-xs rounded-full">{{ pin.section_name }}</span>
                    {% endif %}
                </div>
                <div class="pin-info">
                    <h3 class="font-medium text-gray-900 text-sm leading-tight mb-2 line-clamp-2">{{ pin.title }}</h3>
                    <div class="flex items-center justify-between">
                        <a href="{{ url_for('board', board_id=pin.board_id) }}?highlight={{ pin.id }}" class="board-link text-primary-500 hover:text-primary-600 text-xs flex items-center space-x-1 transition-all duration-200 hover:bg-primary-50 hover:px-2 hover:py-1 hover:rounded-md" title="Go to {{ pin.board_name }}" onclick="if(event) { event.stopPropagation(); }">
                            <span>{{ pin.board_name }}</span>
                            <span>‚Üí</span>
                        </a>
                    </div>
                </div>
            </a>
        </div>
        {% endfor %}
    </div>
</div>

<!-- Board Settings Modals -->
<div class="modal" id="renameBoardModal">
    <div class="modal-content">
        <h3>Rename Board</h3>
        <input type="text" id="newBoardName" placeholder="New board name" class="board-input">
        <div class="modal-actions">
            <button class="button secondary-button" onclick="hideRenameBoardModal()">Cancel</button>
            <button class="button primary-button" onclick="renameBoard()">Rename</button>
        </div>
    </div>
</div>

<div class="modal" id="moveBoardModal">
    <div class="modal-content">
        <h3>Convert Board to Section</h3>
        <p style="margin-bottom: 15px; color: #666; font-size: 14px;">
            This will convert "{{ board.name }}" into a section within another board. 
            All pins and subsections will be moved to the selected board.
        </p>
        <select id="targetBoardSelect">
            <option value="">Select a target board...</option>
            {% for other_board in all_boards %}
            {% if other_board.id != board.id %}
            <option value="{{ other_board.id }}">{{ other_board.name }}</option>
            {% endif %}
            {% endfor %}
        </select>
        <div class="modal-actions">
            <button class="button secondary-button" onclick="hideMoveBoardModal()">Cancel</button>
            <button class="button primary-button" onclick="moveBoard()">Convert to Section</button>
        </div>
    </div>
</div>

<div class="modal" id="deleteBoardModal">
    <div class="modal-content">
        <h3>Delete Board</h3>
        <p>Are you sure you want to delete this board? This action cannot be undone.</p>
        <div class="modal-actions">
            <button class="button secondary-button" onclick="hideDeleteBoardModal()">Cancel</button>
            <button class="button delete-button" onclick="deleteBoard()">Delete</button>
        </div>
    </div>
</div>


<style>

/* Section Circles */
.section-circles-container {
    margin: 20px 0;
    padding: 0 20px;
    overflow: hidden;
}

.section-circles-scroll {
    display: flex;
    gap: 16px;
    overflow-x: auto;
    padding: 10px 0;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: thin;
    scrollbar-color: #cbd5e0 #f7fafc;
}

.section-circles-scroll::-webkit-scrollbar {
    height: 6px;
}

.section-circles-scroll::-webkit-scrollbar-track {
    background: #f7fafc;
    border-radius: 3px;
}

.section-circles-scroll::-webkit-scrollbar-thumb {
    background: #cbd5e0;
    border-radius: 3px;
}

.section-circles-scroll::-webkit-scrollbar-thumb:hover {
    background: #a0aec0;
}

.section-circle {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px;
    border-radius: 12px;
    transition: all 0.2s ease;
    min-width: 80px;
    max-width: 100px;
}

.section-circle:hover {
    background: #f7fafc;
    transform: translateY(-2px);
}

.section-circle.active {
    background: #ebf4ff;
}

.section-circle-image-wrapper {
    position: relative;
    flex-shrink: 0;
    transition: transform 0.2s ease;
}

.section-circle-image {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    overflow: hidden;
    border: 3px solid #e2e8f0;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f7fafc;
}

.section-circle.active .section-circle-image {
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

.section-circle:hover .section-circle-image {
    border-color: #3b82f6;
}

.section-circle:hover .section-circle-image-wrapper {
    transform: scale(1.05);
}

.section-circle-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.section-circle-image.all-pins-circle {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.section-circle-image.all-pins-circle svg {
    width: 32px;
    height: 32px;
    color: white;
}

.section-circle-name {
    font-size: 12px;
    font-weight: 500;
    color: #4a5568;
    text-align: center;
    line-height: 1.2;
    max-width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
}

/* Pin count badge on section circles */
.section-pin-count {
    position: absolute;
    bottom: -2px;
    right: -2px;
    background: #3b82f6;
    color: white;
    font-size: 10px;
    font-weight: 600;
    padding: 2px 5px;
    border-radius: 10px;
    min-width: 18px;
    text-align: center;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

/* Empty section styling */
.section-circle.empty-section .section-circle-image {
    opacity: 0.5;
    border-color: #cbd5e0;
}

.section-circle.empty-section:hover .section-circle-image {
    opacity: 0.7;
    border-color: #a0aec0;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    word-break: break-word;
}

.section-circle.active .section-circle-name {
    color: #2563eb;
    font-weight: 600;
}

@media (max-width: 640px) {
    .section-circle {
        min-width: 70px;
        max-width: 80px;
    }
    
    .section-circle-image {
        width: 56px;
        height: 56px;
    }
    
    .section-circle-name {
        font-size: 11px;
    }
    
    .section-pin-count {
        font-size: 9px;
        padding: 1px 4px;
        min-width: 16px;
    }
}

/* Masonry layout using CSS columns */
#pinsGrid {
    padding: 20px;
    column-count: 5;
    column-gap: 16px;
}

/* Disable ALL transitions during initial load to prevent sliding effect */
#pinsGrid.loading-layout * {
    transition: none !important;
    animation: none !important;
}

#pinsGrid.loading-layout .pin-card {
    transition: none !important;
}

#pinsGrid.loading-layout .image-container {
    transition: none !important;
}

@media (max-width: 1600px) {
    #pinsGrid { column-count: 4; }
}

@media (max-width: 1200px) {
    #pinsGrid { column-count: 3; }
}

@media (max-width: 800px) {
    #pinsGrid { column-count: 2; }
}

@media (max-width: 500px) {
    #pinsGrid { column-count: 1; }
}

.pin-card {
    display: inline-block;
    width: 100%;
    margin-bottom: 16px;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: transform 0.2s, box-shadow 0.2s;
    position: relative;
    background: white;
    /* Contain layout to prevent shifts from propagating to other cards */
    contain: layout style;
    /* Prevent breaks inside pin cards in CSS columns */
    break-inside: avoid;
}

/* Default neutral appearance for pins without colors */
.pin-card:not([data-colors-extracted="true"]) {
    background: white;
    border: 1px solid #e9ecef;
}

.pin-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
}

/* Highlight effect for specific pins */
.pin-card.highlighted {
    animation: highlightPulse 2s ease-in-out;
    border: 2px solid #3b82f6;
    box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
}

@keyframes highlightPulse {
    0% {
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
        transform: scale(1.02);
    }
    50% {
        box-shadow: 0 0 0 10px rgba(59, 130, 246, 0.3);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
        transform: scale(1);
    }
}



/* Image container with dynamic aspect ratio preservation */
.image-container {
    position: relative;
    width: 100%;
    overflow: hidden;
    background: linear-gradient(135deg, var(--dominant-color, #f8f9fa) 0%, var(--secondary-color, #e9ecef) 100%);
    /* Height will be set by JavaScript based on image dimensions */
    min-height: 150px;
    /* Ensure container displays as block to get proper width */
    display: block;
    /* Remove any spacing that creates gaps */
    margin: 0;
    padding: 0;
    line-height: 0; /* Prevent inline spacing */
    /* Contain size to prevent layout recalculation */
    contain: strict;
}

/* When height is locked, absolutely fix the container size */
.image-container[data-height-locked="true"] {
    contain: size layout style;
}

/* Default neutral appearance for image containers without colors */
.pin-card:not([data-colors-extracted="true"]) .image-container {
    background: #f8f9fa;
}

/* Quote-style layout for cards with content at top and space below */
.pin-card.quote-style {
    display: flex;
    flex-direction: column;
    min-height: 400px; /* Ensure minimum height for the blank space effect */
}

.pin-card.quote-style .image-container {
    flex: 0 0 auto; /* Don't grow, maintain size */
    margin-bottom: 0;
    /* aspect-ratio removed - JavaScript will set height dynamically */
}

.pin-card.quote-style .pin-info {
    flex: 1; /* Take up remaining space */
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    padding: 2rem 1rem; /* More padding for the blank space effect */
    min-height: 200px; /* Ensure substantial blank space */
}

.pin-card.quote-style .pin-info h3 {
    margin-bottom: 1rem;
    font-size: 1.1rem;
    line-height: 1.4;
}

/* Optional: Add a subtle background pattern or gradient to the blank space */
.pin-card.quote-style .pin-info::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
    opacity: 0.3;
    z-index: -1;
}

/* Skeleton loader animation */
.skeleton-loader {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
        90deg,
        rgba(240, 240, 240, 0.6) 0%,
        rgba(220, 220, 220, 0.8) 50%,
        rgba(240, 240, 240, 0.6) 100%
    );
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    z-index: 1;
    border-radius: 8px;
}

@keyframes shimmer {
    0% {
        background-position: -200% 0;
    }
    100% {
        background-position: 200% 0;
    }
}

/* Pin images */
.pin-image {
    width: 100%;
    height: 100%;
    max-width: 100%;
    /* max-height removed - container height is controlled by JavaScript */
    max-height: none !important; /* Override any max-height from base.html or other styles */
    display: block;
    transition: transform 0.2s, opacity 0.3s;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
    opacity: 0;
    object-fit: cover;
    object-position: center center; /* Center the image to prevent cropping issues */
}

.pin-image.loaded {
    opacity: 1;
}

.pin-card:hover .pin-image {
    transform: scale(1.05);
}

/* Legacy support for old class name */
.pin-image-container {
    position: relative;
    width: 100%;
    overflow: hidden;
    background: linear-gradient(135deg, var(--dominant-color, #f8f9fa) 0%, var(--secondary-color, #e9ecef) 100%);
    transition: background 0.5s ease;
}

.pin-card:not([data-colors-extracted="true"]) .pin-image-container {
    background: #f8f9fa;
}

.pin-info {
    padding: 16px;
    position: relative;
    background: white;
}

.pin-info h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 500;
    line-height: 1.4;
    color: #333;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

.pin-card a {
    text-decoration: none;
    color: #333 !important;
    display: block;
}

.pin-card a:hover {
    color: #333 !important;
}

.source-link-icon {
    position: absolute;
    top: 16px;
    right: 16px;
    background: rgba(255,255,255,0.9);
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    text-decoration: none;
    color: #666;
    transition: all 0.2s;
}

.source-link-icon:hover {
    background: white;
    color: #007bff;
    transform: scale(1.1);
}

.section-badge {
    position: absolute;
    top: 12px;
    left: 12px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
}

/* Modal styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
}

.modal.active {
    display: block;
}

.modal-content {
    background-color: white;
    margin: 15% auto;
    padding: 20px;
    border-radius: 8px;
    width: 90%;
    max-width: 400px;
}

.modal-content h3 {
    margin-top: 0;
    margin-bottom: 20px;
}

.modal-actions {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 20px;
}

.button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background-color 0.2s;
}

.primary-button {
    background-color: #007bff;
    color: white;
}

.primary-button:hover {
    background-color: #0056b3;
}

.secondary-button {
    background-color: #6c757d;
    color: white;
}

.secondary-button:hover {
    background-color: #545b62;
}

.delete-button {
    background-color: #dc3545;
    color: white;
}

.delete-button:hover {
    background-color: #c82333;
}

.board-input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.board-input:focus {
    outline: none;
    border-color: #007bff;
}

</style>

<script>
// Development mode check
const IS_DEVELOPMENT = {% if is_development %}true{% else %}false{% endif %};

// Development-only console logging
function devLog(...args) {
    if (IS_DEVELOPMENT) {
        console.log(...args);
    }
}

function devWarn(...args) {
    if (IS_DEVELOPMENT) {
        console.warn(...args);
    }
}

function devError(...args) {
    if (IS_DEVELOPMENT) {
        console.error(...args);
    }
}

// Processing state for board
let processingState = {
    phase: 'idle', // 'idle', 'caching', 'extracting', 'health-checking', 'complete'
    totalPins: 0,
    cachedPins: 0,
    extractedPins: 0,
    pinsWithLinks: 0,
    healthCheckedPins: 0,
    uncachedPins: [],
    abortController: null,  // For cancelling fetch requests
    pendingTimeouts: []     // Track all pending timeouts for cleanup
};

// Wrapper function to track timeouts for cleanup
function scheduleTimeout(callback, delay) {
    const timeoutId = setTimeout(() => {
        // Remove from pending list when executed
        const index = processingState.pendingTimeouts.indexOf(timeoutId);
        if (index > -1) {
            processingState.pendingTimeouts.splice(index, 1);
        }
        callback();
    }, delay);
    processingState.pendingTimeouts.push(timeoutId);
    return timeoutId;
}

// Cleanup function to stop all processing when navigating away
function stopAllProcessing() {
    console.log('üõë Stopping all background processing...');
    
    // Abort any pending fetch requests
    if (processingState.abortController) {
        processingState.abortController.abort();
        processingState.abortController = null;
    }
    
    // Clear all pending timeouts
    processingState.pendingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    processingState.pendingTimeouts = [];
    
    // Reset state
    processingState.phase = 'idle';
}

// Stop processing when page is hidden or unloading
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        stopAllProcessing();
    }
});

window.addEventListener('beforeunload', stopAllProcessing);
window.addEventListener('pagehide', stopAllProcessing);

// Board management functions
function toggleBoardSettings() {
    const menu = document.getElementById('boardSettingsMenu');
    menu.classList.toggle('hidden');
}

// Close board settings menu when clicking outside
document.addEventListener('click', (e) => {
    const menu = document.getElementById('boardSettingsMenu');
    const button = e.target.closest('button[onclick="toggleBoardSettings()"]');
    
    if (!button && !menu.contains(e.target) && !menu.classList.contains('hidden')) {
        menu.classList.add('hidden');
    }
});

function showRenameBoardModal() {
    document.getElementById('renameBoardModal').classList.add('active');
    document.getElementById('newBoardName').value = '{{ board.name }}';
    document.getElementById('newBoardName').focus();
}

function hideRenameBoardModal() {
    document.getElementById('renameBoardModal').classList.remove('active');
}

function showMoveBoardModal() {
    document.getElementById('moveBoardModal').classList.add('active');
}

function hideMoveBoardModal() {
    document.getElementById('moveBoardModal').classList.remove('active');
}

function showDeleteBoardModal() {
    document.getElementById('deleteBoardModal').classList.add('active');
}

function hideDeleteBoardModal() {
    document.getElementById('deleteBoardModal').classList.remove('active');
}

function renameBoard() {
    const newName = document.getElementById('newBoardName').value.trim();
    if (!newName) {
        alert('Please enter a board name');
        return;
    }

    fetch(`/rename-board/{{ board.id }}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            name: newName
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            alert('Failed to rename board');
        }
    })
    .catch(error => {
        devError('Error:', error);
        alert('Failed to rename board');
    });
}

function moveBoard() {
    const targetBoardId = document.getElementById('targetBoardSelect').value;
    if (!targetBoardId) {
        alert('Please select a target board');
        return;
    }

    fetch(`/move-board/{{ board.id }}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            target_board_id: targetBoardId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = `/board/${targetBoardId}`;
        } else {
            alert('Failed to move board');
        }
    })
    .catch(error => {
        devError('Error:', error);
        alert('Failed to move board');
    });
}

function deleteBoard() {
    fetch(`/delete-board/{{ board.id }}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            window.location.href = '/';
        } else {
            alert('Failed to delete board');
        }
    })
    .catch(error => {
        devError('Error:', error);
        alert('Failed to delete board');
    });
}

// Apply pin size from localStorage immediately
function applyPinSizeFromStorage() {
    const savedPinSize = parseInt(localStorage.getItem('boardPinSize')) || 3;
    const pinsGrid = document.getElementById('pinsGrid');
    
    if (pinsGrid) {
        const columnCounts = {
            1: 7,  // Tiny - most columns
            2: 6,  // Small
            3: 5,  // Medium (default)
            4: 4,  // Large
            5: 3   // Huge - fewest columns
        };
        const columnCount = columnCounts[savedPinSize] || columnCounts[3];
        pinsGrid.style.columnCount = columnCount;
    }
    
    // Also set the CSS variable for pin width (for backward compatibility)
    const pinWidths = {
        1: '150px',  // Tiny
        2: '200px',  // Small  
        3: '250px',  // Medium
        4: '300px',  // Large
        5: '400px'   // Huge
    };
    const pinWidth = pinWidths[savedPinSize] || pinWidths[3];
    document.documentElement.style.setProperty('--pin-width', pinWidth);
}

// Initialize the board
document.addEventListener('DOMContentLoaded', function() {
    // Apply pin size immediately from localStorage before any layout operations
    applyPinSizeFromStorage();
    
    initializeSectionFiltering();
    initializeBoardManagement();
    
    // Check if we have a highlight parameter - if so, prioritize layout stability
    const urlParams = new URLSearchParams(window.location.search);
    const hasHighlight = urlParams.get('highlight');
    
    // Set up lazy loading for board pins (if not featured/fully loaded)
    const isFeatured = {% if is_featured %}true{% else %}false{% endif %};
    const totalPinCount = {{ total_pin_count or 0 }};
    const initialPinCount = {{ pins|length if pins else 0 }};
    
    if (!isFeatured && totalPinCount > initialPinCount) {
        // Set up infinite scroll for loading more pins
        setupBoardPinsLazyLoad(initialPinCount, totalPinCount);
    }
    
    if (hasHighlight) {
        // For highlight navigation, delay other operations to ensure layout is stable
        // Don't restore scroll position when highlighting - we'll scroll to the pin instead
        
        // Handle pin highlighting from URL parameter (will wait for layout)
        handlePinHighlighting();
        
        // Delay automatic processing when highlighting to avoid layout shifts
        setTimeout(() => {
            startAutomaticProcessing();
        }, 2500); // Delay longer to ensure highlight completes first
        
        // Save scroll position when clicking on a pin (still set this up)
        saveScrollOnPinClick();
    } else {
        // Normal flow - no highlight
        restoreScrollPosition();
        
        // Save scroll position when clicking on a pin
        saveScrollOnPinClick();
        
        // Start automatic processing after board loads
        setTimeout(() => {
            startAutomaticProcessing();
        }, 1000);
    }
});

// Note: Space is pre-reserved using preReserveAllImageSpaces() to prevent layout shifts
// correctImageContainerHeight is called on image load but respects locked heights to avoid recalculation

// Infinite scroll for loading more pins on board page
function setupBoardPinsLazyLoad(initialCount, totalCount) {
    let currentOffset = initialCount;
    let isLoading = false;
    const boardId = getBoardId();
    
    let scrollThrottle = null;
    function handleScroll() {
        if (scrollThrottle || isLoading) return;
        
        scrollThrottle = setTimeout(() => {
            scrollThrottle = null;
            
            // Check if user is near bottom of page (within 500px)
            const scrollPosition = window.innerHeight + window.scrollY;
            const pageHeight = document.documentElement.scrollHeight;
            const distanceFromBottom = pageHeight - scrollPosition;
            
            // Load more when within 500px of bottom and there are more pins
            if (distanceFromBottom < 500 && currentOffset < totalCount && !isLoading) {
                isLoading = true;
                
                fetch(`/api/board/${boardId}/pins?offset=${currentOffset}&limit=40`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.pins && data.pins.length > 0) {
                            const pinsGrid = document.getElementById('pinsGrid');
                            if (pinsGrid) {
                                // Append new pins to the grid
                                const newCards = [];
                                data.pins.forEach(pin => {
                                    const pinCard = createBoardPinCard(pin);
                                    pinsGrid.appendChild(pinCard);
                                    newCards.push(pinCard);
                                });
                                
                                // Pre-reserve space for newly loaded pins (after they're in DOM)
                                requestAnimationFrame(() => {
                                    newCards.forEach(card => preReserveImageSpace(card));
                                    // Apply current section filter to newly loaded pins
                                    if (typeof applyCurrentSectionFilter === 'function') {
                                        applyCurrentSectionFilter();
                                    }
                                });
                                
                                currentOffset += data.pins.length;
                                
                                // Reattach scroll handlers to new pin links
                                saveScrollOnPinClick();
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Error loading more pins:', error);
                    })
                    .finally(() => {
                        isLoading = false;
                    });
            }
        }, 200); // Throttle scroll events to every 200ms
    }
    
    window.addEventListener('scroll', handleScroll);
}

// Create a pin card element from pin data for board page
function createBoardPinCard(pin) {
    const div = document.createElement('div');
    div.className = 'pin-card bg-white rounded-xl shadow-sm hover:shadow-lg transition-all duration-300 overflow-hidden group';
    
    if (pin.dominant_color_1 && pin.dominant_color_2) {
        div.style.setProperty('--dominant-color', pin.dominant_color_1);
        div.style.setProperty('--secondary-color', pin.dominant_color_2);
        div.setAttribute('data-colors-extracted', 'true');
        div.setAttribute('data-has-db-colors', 'true');
    } else {
        div.setAttribute('data-has-db-colors', 'false');
    }
    
    div.setAttribute('data-pin-id', pin.id);
    div.setAttribute('data-image-url', pin.image_url || '');
    div.setAttribute('data-section-id', pin.section_id || 'all');
    div.setAttribute('data-cached-width', pin.cached_width || '');
    div.setAttribute('data-cached-height', pin.cached_height || '');
    div.id = `pin-${pin.id}`;
    
    if (pin.cached_filename) {
        div.setAttribute('data-cached-url', `/cached/${pin.cached_filename}`);
        div.setAttribute('data-has-cached', 'true');
    } else {
        div.setAttribute('data-has-cached', 'false');
    }
    
    const imageSrc = pin.cached_filename ? `/cached/${pin.cached_filename}` : (pin.image_url || '/static/images/default_pin.png');
    
    // Calculate pre-determined height if dimensions are available
    let containerStyle = '';
    if (pin.cached_width && pin.cached_height) {
        // Will be calculated after appending to DOM when container width is known
        div.setAttribute('data-needs-height-calc', 'true');
    }
    
    div.innerHTML = `
        <a href="/pin/${pin.id}" class="block">
            <div class="relative overflow-hidden image-container">
                <div class="skeleton-loader"></div>
                <img src="${escapeHtml(imageSrc)}" 
                     alt="${escapeHtml(pin.title || '')}" 
                     class="pin-image group-hover:scale-105 transition-transform duration-300" 
                     loading="lazy"
                     data-original-url="${pin.image_url || ''}"
                     onload="this.classList.add('loaded'); if(this.previousElementSibling) this.previousElementSibling.style.display='none'; correctImageContainerHeight(this);"
                     onerror="this.src='/static/images/default_pin.png'; this.classList.add('loaded'); if(this.previousElementSibling) this.previousElementSibling.style.display='none';">
                ${pin.section_name ? `<span class="absolute top-2 left-2 px-2 py-1 bg-black bg-opacity-70 text-white text-xs rounded-full">${escapeHtml(pin.section_name)}</span>` : ''}
            </div>
            <div class="pin-info">
                <h3 class="font-medium text-gray-900 text-sm leading-tight mb-2 line-clamp-2">${escapeHtml(pin.title || '')}</h3>
                <div class="flex items-center justify-between">
                    <a href="/board/${pin.board_id}" class="board-link text-primary-500 hover:text-primary-600 text-xs flex items-center space-x-1 transition-all duration-200 hover:bg-primary-50 hover:px-2 hover:py-1 hover:rounded-md" title="Go to board" onclick="if(event) { event.stopPropagation(); event.preventDefault ? event.preventDefault() : null; }">
                        <span>Board</span>
                        <span>‚Üí</span>
                    </a>
                </div>
            </div>
        </a>
    `;
    
    return div;
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Save scroll position when clicking on pins
function saveScrollOnPinClick() {
    const pinLinks = document.querySelectorAll('.pin-card a');
    pinLinks.forEach(link => {
        link.addEventListener('click', function() {
            const boardId = getBoardId();
            if (boardId) {
                sessionStorage.setItem(`board_${boardId}_scroll`, window.scrollY);
            }
        });
    });
}

// Restore scroll position when returning to board
function restoreScrollPosition() {
    const boardId = getBoardId();
    if (boardId) {
        const savedScroll = sessionStorage.getItem(`board_${boardId}_scroll`);
        if (savedScroll !== null) {
            // Small delay to ensure content is loaded
            setTimeout(() => {
                window.scrollTo(0, parseInt(savedScroll));
                // Clear the saved position after restoring
                sessionStorage.removeItem(`board_${boardId}_scroll`);
            }, 100);
        }
    }
}

// Debug function accessible from browser console
window.debugUrlHealth = function() {
    const boardId = getBoardId();
    devLog('üîç Debugging URL health for board', boardId);
    
    fetch(`/api/debug-url-health/${boardId}`)
        .then(response => response.json())
        .then(data => {
            devLog('üìä URL Health Debug Results:', data);
            
            if (data.success) {
                devLog(`\nüìã Summary:`);
                devLog(`- Board ID: ${data.board_id}`);
                devLog(`- Pins with links: ${data.stats.pins_with_links}`);
                devLog(`- Health checked: ${data.stats.health_checked_count}`);
                devLog(`- Live links: ${data.stats.live_links}`);
                devLog(`- Broken links: ${data.stats.broken_links}`);
                devLog(`- Unknown links: ${data.stats.unknown_links}`);
                devLog(`- Needs checking: ${data.needs_health_checking}`);
                
                devLog(`\nüîó URLs that would be checked:`, data.urls_that_would_be_checked);
                devLog(`\nüìå All pins with links:`, data.pins_with_links);
            }
        })
        .catch(error => {
            devError('‚ùå Debug URL health failed:', error);
        });
};

function startAutomaticProcessing() {
    devLog('üöÄ Starting automatic image processing...');
    devLog('üìä System will process in 3 phases: 1) Cache Images ‚Üí 2) Extract Colors ‚Üí 3) Check URL Health');
    
    // Create new AbortController for this processing session
    processingState.abortController = new AbortController();
    
    // Count pins and their current state
    const allPins = document.querySelectorAll('.pin-card');
    const uncachedPins = Array.from(allPins).filter(pin => {
        const imageUrl = pin.getAttribute('data-image-url');
        const hasCached = pin.getAttribute('data-has-cached') === 'true';
        return imageUrl && imageUrl.startsWith('http') && !hasCached;
    });
    
    const pinsWithoutColors = Array.from(allPins).filter(pin => {
        return pin.getAttribute('data-has-db-colors') === 'false';
    });
    
    processingState.totalPins = allPins.length;
    processingState.uncachedPins = uncachedPins;
    processingState.cachedPins = allPins.length - uncachedPins.length;
    processingState.extractedPins = allPins.length - pinsWithoutColors.length;
    
    devLog(`üìä Board Analysis:`);
    devLog(`  - Total pins: ${allPins.length}`);
    devLog(`  - Uncached external images: ${uncachedPins.length}`);
    devLog(`  - Pins without colors: ${pinsWithoutColors.length}`);
    
    updateProcessingStatus();
    
    if (uncachedPins.length > 0) {
        devLog('üìÅ Phase 1: Starting image caching...');
        // Start caching phase
        processingState.phase = 'caching';
        updateProcessingStatus();
        startImageCaching(uncachedPins.length);
    } else if (pinsWithoutColors.length > 0) {
        devLog('‚úÖ Phase 1: All images already cached, skipping to phase 2...');
        devLog('üé® Phase 2: Starting color extraction...');
        // Skip to extraction phase
        processingState.phase = 'extracting';
        updateProcessingStatus();
        startColorExtraction();
    } else {
        devLog('‚úÖ Phase 1 & 2: All images cached and colors extracted, skipping to phase 3...');
        devLog('üîó Phase 3: Checking URL health...');
        // Check if we need URL health checking
        checkAndStartUrlHealthChecking();
    }
}

function startImageCaching(imageCount) {
    devLog(`üìÅ Starting to cache ${imageCount} images...`);
    
    const boardId = getBoardId();
    devLog(`üìÅ Caching images for board ${boardId}...`);
    
    fetch('/cache-images', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            limit: imageCount,
            board_id: parseInt(boardId)
        }),
        signal: processingState.abortController?.signal
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            devLog('‚úÖ Image caching started:', data.message);
            // Poll for caching completion
            pollCachingProgress();
        } else {
            devError('‚ùå Failed to start image caching:', data.error);
            processingState.phase = 'idle';
            updateProcessingStatus();
        }
    })
    .catch(error => {
        devError('‚ùå Error starting image caching:', error);
        processingState.phase = 'idle';
        updateProcessingStatus();
    });
}

function pollCachingProgress() {
    let previousCachedCount = processingState.cachedPins;
    let pollAttempts = 0;
    const maxPollAttempts = 40; // Maximum 2 minutes of polling (40 * 3 seconds)
    let noProgressCount = 0;
    const maxNoProgressCount = 10; // Stop if no progress for 30 seconds
    
    // Check caching progress every 3 seconds
    const checkProgress = () => {
        pollAttempts++;
        devLog(`üîÑ Polling caching progress... (attempt ${pollAttempts}/${maxPollAttempts})`);
        
        // Check if we've exceeded maximum polling attempts
        if (pollAttempts >= maxPollAttempts) {
            devWarn('‚è∞ Maximum polling time reached, stopping caching phase');
            devWarn('üìã Some images may have failed to cache (videos, rate limits, etc.)');
            devLog('‚úÖ Phase 1 complete: Moving to color extraction (with remaining images)');
            processingState.phase = 'extracting';
            updateProcessingStatus();
            setTimeout(startColorExtraction, 2000);
            return;
        }
        
        // Check if we have new cached images by making a quick API call
        fetch(`/api/board-status/${getBoardId()}`, {
            signal: processingState.abortController?.signal
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    devLog(`üìä Caching status: ${data.cached_count}/${processingState.totalPins} images cached`);
                    
                    // Update cached pins in the DOM
                    if (data.cached_pins && data.cached_pins.length > 0) {
                        devLog(`üì• Updating ${data.cached_pins.length} newly cached pins in DOM`);
                        updateCachedPinsInDOM(data.cached_pins);
                    }
                    
                    // Update extracted pins in the DOM
                    if (data.extracted_pins && data.extracted_pins.length > 0) {
                        devLog(`üé® Updating ${data.extracted_pins.length} newly color-extracted pins in DOM`);
                        updateExtractedPinsInDOM(data.extracted_pins);
                    }
                    
                    // Check for progress
                    if (data.cached_count > previousCachedCount) {
                        const newlyCached = data.cached_count - previousCachedCount;
                        devLog(`üìÅ +${newlyCached} images cached (${data.cached_count}/${processingState.totalPins} total)`);
                        previousCachedCount = data.cached_count;
                        noProgressCount = 0; // Reset no progress counter
                    } else {
                        noProgressCount++;
                        devLog(`üìã No new images cached (${noProgressCount}/${maxNoProgressCount} attempts without progress)`);
                    }
                    
                    // Update processing state counts
                    processingState.cachedPins = data.cached_count;
                    processingState.extractedPins = data.extracted_count;
                    updateProcessingStatus();
                    
                    // Check if all external images are cached by counting current DOM state
                    const allPins = document.querySelectorAll('.pin-card');
                    const uncachedExternalPins = Array.from(allPins).filter(pin => {
                        const imageUrl = pin.getAttribute('data-image-url');
                        const hasCached = pin.getAttribute('data-has-cached') === 'true';
                        return imageUrl && imageUrl.startsWith('http') && !hasCached;
                    });
                    
                    devLog(`üìã Remaining uncached external images: ${uncachedExternalPins.length}`);
                    
                    if (uncachedExternalPins.length <= 0) {
                        devLog('üéâ All external images have been cached!');
                        devLog('‚úÖ Phase 1 complete: Image caching finished');
                        devLog('üé® Phase 2: Starting color extraction...');
                        processingState.phase = 'extracting';
                        updateProcessingStatus();
                        // Wait a moment then start color extraction
                        setTimeout(startColorExtraction, 2000);
                    } else if (noProgressCount >= maxNoProgressCount) {
                        devWarn(`‚è∞ No progress for ${maxNoProgressCount * 3} seconds, moving to next phase`);
                        devWarn(`üìã ${uncachedExternalPins.length} images couldn't be cached (likely videos or rate-limited)`);
                        devLog('‚úÖ Phase 1 complete: Moving to color extraction (with remaining images)');
                        processingState.phase = 'extracting';
                        updateProcessingStatus();
                        setTimeout(startColorExtraction, 2000);
                    } else {
                        devLog(`‚è≥ Still waiting for ${uncachedExternalPins.length} images, will check again in 3 seconds...`);
                        // Continue polling
                        setTimeout(checkProgress, 3000);
                    }
                } else {
                    devWarn('‚ö†Ô∏è API returned error:', data);
                    // Continue polling but count as no progress
                    noProgressCount++;
                    if (noProgressCount >= maxNoProgressCount) {
                        devWarn('‚ö†Ô∏è Too many API errors, moving to next phase');
                        processingState.phase = 'extracting';
                        updateProcessingStatus();
                        setTimeout(startColorExtraction, 2000);
                    } else {
                        setTimeout(checkProgress, 5000);
                    }
                }
            })
            .catch(error => {
                devWarn('‚ùå Error checking caching progress:', error);
                noProgressCount++;
                if (noProgressCount >= maxNoProgressCount) {
                    devWarn('‚ùå Too many network errors, moving to next phase');
                    processingState.phase = 'extracting';
                    updateProcessingStatus();
                    setTimeout(startColorExtraction, 2000);
                } else {
                    // Continue polling anyway
                    setTimeout(checkProgress, 5000);
                }
            });
    };
    
    // Start polling
    devLog('‚è≥ Starting to poll for caching progress every 3 seconds...');
    devLog('üìã Will automatically move to next phase if no progress or after 2 minutes');
    setTimeout(checkProgress, 3000);
}

function updateCachedPinsInDOM(cachedPins) {
    cachedPins.forEach(cachedPin => {
        const pinElement = document.querySelector(`[data-pin-id="${cachedPin.id}"]`);
        if (pinElement) {
            const currentHasCached = pinElement.getAttribute('data-has-cached') === 'true';
            
            if (!currentHasCached) {
                // Update the pin element to show it's now cached
                pinElement.setAttribute('data-has-cached', 'true');
                pinElement.setAttribute('data-cached-url', `/cached/${cachedPin.cached_filename}`);
                
                // Update the image source to use the cached version
                const imgElement = pinElement.querySelector('.pin-image');
                if (imgElement) {
                    const originalSrc = imgElement.src;
                    
                    // Remove loaded class and add it back when new image loads
                    imgElement.classList.remove('loaded');
                    imgElement.onload = function() {
                        imgElement.classList.add('loaded');
                        // Hide skeleton loader if present
                        const skeleton = imgElement.previousElementSibling;
                        if (skeleton && skeleton.classList.contains('skeleton-loader')) {
                            skeleton.style.display = 'none';
                        }
                    };
                    
                    imgElement.src = `/cached/${cachedPin.cached_filename}`;
                    imgElement.setAttribute('data-original-url', originalSrc);
                }
                
                devLog(`‚úÖ Updated pin ${cachedPin.id} to use cached image: ${cachedPin.cached_filename}`);
            }
        }
    });
}

function updateExtractedPinsInDOM(extractedPins) {
    extractedPins.forEach(extractedPin => {
        const pinElement = document.querySelector(`[data-pin-id="${extractedPin.id}"]`);
        if (pinElement) {
            const currentHasColors = pinElement.getAttribute('data-has-db-colors') === 'true';
            
            if (!currentHasColors && extractedPin.color1 && extractedPin.color2) {
                // Update the pin element to show colors are extracted
                pinElement.setAttribute('data-has-db-colors', 'true');
                pinElement.setAttribute('data-colors-extracted', 'true');
                
                // Apply the colors to the pin
                pinElement.style.setProperty('--dominant-color', extractedPin.color1);
                pinElement.style.setProperty('--secondary-color', extractedPin.color2);
                
                devLog(`‚úÖ Updated pin ${extractedPin.id} with extracted colors: ${extractedPin.color1}, ${extractedPin.color2}`);
            }
        }
    });
}

function startColorExtraction() {
    devLog('üé® Starting color extraction phase...');
    
    // Get all pins that need color extraction AND have cached images
    // (Color extraction only works on cached images due to CORS restrictions on external URLs)
    const allPinsNeedingColors = document.querySelectorAll('.pin-card[data-has-db-colors="false"]');
    const pinsNeedingColors = Array.from(allPinsNeedingColors).filter(pin => 
        pin.getAttribute('data-has-cached') === 'true'
    );
    const uncachedPinsCount = allPinsNeedingColors.length - pinsNeedingColors.length;
    
    devLog(`üìä Found ${pinsNeedingColors.length} pins that need color extraction (with cached images)`);
    if (uncachedPinsCount > 0) {
        devLog(`‚è≥ ${uncachedPinsCount} pins skipped - waiting for image caching (colors will be extracted server-side)`);
    }
    
    if (pinsNeedingColors.length === 0) {
        if (uncachedPinsCount > 0) {
            devLog('‚è≥ No cached images available for color extraction - colors will be extracted when images are cached');
        } else {
            devLog('‚úÖ No pins need color extraction, phase 2 complete');
        }
        devLog('üîó Phase 3: Starting URL health checking...');
        checkAndStartUrlHealthChecking();
        return;
    }
    
    let processed = 0;
    const total = pinsNeedingColors.length;
    
    const processNextPin = () => {
        if (processed >= total) {
            devLog('üéâ Color extraction phase complete!');
            devLog('‚úÖ Phase 2 complete: Color extraction finished');
            devLog('üîó Phase 3: Starting URL health checking...');
            // Move to URL health checking phase
            checkAndStartUrlHealthChecking();
            return;
        }
        
        const pin = pinsNeedingColors[processed];
        const pinId = pin.getAttribute('data-pin-id');
        const pinTitle = pin.querySelector('h3')?.textContent || `Pin ${pinId}`;
        
        devLog(`üé® Processing pin ${processed + 1}/${total}: "${pinTitle}" (ID: ${pinId})`);
        
        const img = pin.querySelector('.pin-image');
        
        if (img) {
            extractColorsFromPin(pin, img, (success) => {
                processed++;
                processingState.extractedPins++;
                
                if (success) {
                    devLog(`‚úÖ Colors extracted for pin ${pinId} (${processed}/${total})`);
                } else {
                    devLog(`‚ö†Ô∏è Color extraction failed for pin ${pinId} (${processed}/${total})`);
                }
                
                updateProcessingStatus();
                
                // Show progress every 10 pins or at completion
                if (processed % 10 === 0 || processed === total) {
                    devLog(`üìä Color extraction progress: ${processed}/${total} pins completed`);
                }
                
                // Continue with next pin after a short delay
                setTimeout(processNextPin, 500);
            });
        } else {
            devLog(`‚ö†Ô∏è No image found for pin ${pinId}, skipping...`);
            processed++;
            setTimeout(processNextPin, 100);
        }
    };
    
    devLog('üé® Starting to process pins for color extraction...');
    processNextPin();
}

function extractColorsFromPin(pinCard, img, callback) {
    try {
        // Only extract colors from cached images (external URLs blocked by CORS)
        const hasCachedImage = pinCard.getAttribute('data-has-cached') === 'true';
        const cachedUrl = pinCard.getAttribute('data-cached-url');
        
        if (!hasCachedImage || !cachedUrl) {
            // Skip - colors will be extracted server-side when image is cached
            callback(false);
            return;
        }
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 50;
        canvas.height = 50;
        
        const imageUrl = cachedUrl;
        
        const tempImg = new Image();
        // No need for crossOrigin on local cached images
        
        tempImg.onload = function() {
            try {
                ctx.drawImage(tempImg, 0, 0, 50, 50);
                const colors = extractDominantColorsFromCanvas(canvas);
                
                // Apply colors to the image container
                pinCard.style.setProperty('--dominant-color', colors.primary);
                pinCard.style.setProperty('--secondary-color', colors.secondary);
                pinCard.setAttribute('data-colors-extracted', 'true');
                pinCard.setAttribute('data-has-db-colors', 'true');
                
                // Save to database
                const pinId = pinCard.getAttribute('data-pin-id');
                if (pinId) {
                    saveColorsToDatabase(pinId, colors.primary, colors.secondary);
                }
                
                callback(true); // Success
            } catch (e) {
                devWarn('Could not extract colors from image:', imageUrl, e);
                callback(false); // Failed
            }
        };
        
        tempImg.onerror = function() {
            devWarn('Image failed to load:', imageUrl);
            callback(false); // Failed
        };
        
        tempImg.src = imageUrl;
        
    } catch (e) {
        devWarn('Error processing image:', e);
        callback(false); // Failed
    }
}

function extractDominantColorsFromCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    const colorMap = new Map();
    
    for (let i = 0; i < data.length; i += 4) {
        const r = Math.round(data[i] / 32) * 32;
        const g = Math.round(data[i + 1] / 32) * 32;
        const b = Math.round(data[i + 2] / 32) * 32;
        const alpha = data[i + 3];
        
        if (alpha < 128) continue;
        
        const colorKey = `${r},${g},${b}`;
        colorMap.set(colorKey, (colorMap.get(colorKey) || 0) + 1);
    }
    
    const sortedColors = Array.from(colorMap.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 2);
    
    if (sortedColors.length === 0) {
        return { primary: '#f0f0f0', secondary: '#e0e0e0' };
    }
    
    const primaryRgb = sortedColors[0][0].split(',').map(Number);
    const primary = `rgb(${primaryRgb[0]}, ${primaryRgb[1]}, ${primaryRgb[2]})`;
    
    let secondary;
    if (sortedColors.length > 1) {
        const secondaryRgb = sortedColors[1][0].split(',').map(Number);
        secondary = `rgb(${secondaryRgb[0]}, ${secondaryRgb[1]}, ${secondaryRgb[2]})`;
    } else {
        const lighter = primaryRgb.map(c => Math.min(255, c + 30));
        secondary = `rgb(${lighter[0]}, ${lighter[1]}, ${lighter[2]})`;
    }
    
    return { primary, secondary };
}

function saveColorsToDatabase(pinId, color1, color2) {
    fetch(`/save-pin-colors/${pinId}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            dominant_color_1: color1,
            dominant_color_2: color2
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            devLog(`‚úÖ Saved colors for pin ${pinId}`);
        } else {
            devWarn(`‚ö†Ô∏è Failed to save colors for pin ${pinId}:`, data.error);
        }
    })
    .catch(error => {
        devWarn(`‚ö†Ô∏è Error saving colors for pin ${pinId}:`, error);
    });
}

function checkAndStartUrlHealthChecking() {
    // Get current board status to see if URL health checking is needed
    devLog('üîç Checking if URL health checking is needed...');
    
    fetch(`/api/board-status/${getBoardId()}`, {
        signal: processingState.abortController?.signal
    })
        .then(response => response.json())
        .then(data => {
            devLog('üìä Board status for URL health:', data);
            
            if (data.success) {
                processingState.pinsWithLinks = data.pins_with_links;
                processingState.healthCheckedPins = data.health_checked_count;
                
                devLog(`üìã URL Health Summary:`);
                devLog(`  - Pins with links: ${data.pins_with_links}`);
                devLog(`  - Health checked: ${data.health_checked_count}`);
                devLog(`  - Live links: ${data.live_links}`);
                devLog(`  - Broken links: ${data.broken_links}`);
                devLog(`  - Archived links: ${data.archived_links}`);
                
                const needsChecking = data.pins_with_links - data.health_checked_count;
                
                if (needsChecking > 0) {
                    devLog(`üîó ${needsChecking} URLs need health checking, starting URL health phase...`);
                    // Start URL health checking phase
                    processingState.phase = 'health-checking';
                    updateProcessingStatus();
                    startUrlHealthChecking();
                } else {
                    devLog('‚úÖ All URLs already health checked!');
                    devLog('üéâ All processing phases complete! System is ready.');
                    // Everything is complete
                    processingState.phase = 'complete';
                    updateProcessingStatus();
                }
            } else {
                devWarn('‚ö†Ô∏è Board status API failed:', data);
                devWarn('‚ö†Ô∏è Marking processing as complete due to API failure');
                // If API fails, just mark as complete
                processingState.phase = 'complete';
                updateProcessingStatus();
            }
        })
        .catch(error => {
            devWarn('‚ùå Error checking URL health status:', error);
            devWarn('‚ùå Marking processing as complete due to network error');
            processingState.phase = 'complete';
            updateProcessingStatus();
        });
}

function startUrlHealthChecking() {
    devLog('üîó Starting URL health checking phase...');
    
    const uncheckedUrls = processingState.pinsWithLinks - processingState.healthCheckedPins;
    const batchSize = Math.min(uncheckedUrls, 100);  // Increased from 20 to 100 for faster processing
    
    devLog(`üìä URL Health Status:`);
    devLog(`  - Total pins with links: ${processingState.pinsWithLinks}`);
    devLog(`  - Already checked: ${processingState.healthCheckedPins}`);
    devLog(`  - Remaining to check: ${uncheckedUrls}`);
    devLog(`  - Checking batch size: ${batchSize}`);
    
    fetch(`/api/check-url-health/${getBoardId()}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            limit: batchSize
        }),
        signal: processingState.abortController?.signal
    })
    .then(response => {
        devLog('üåê URL health check API response received');
        return response.json();
    })
    .then(data => {
        devLog('üîó URL health check response:', data);
        
        if (data.success) {
            devLog(`‚úÖ URL health check batch complete: ${data.message}`);
            devLog(`üìä Checked ${data.checked} URLs in this batch`);
            
            // Show detailed results if available
            if (data.results && data.results.length > 0) {
                devLog('üìã Detailed results:');
                data.results.forEach((result, index) => {
                    const statusEmoji = result.status === 'live' ? 'üü¢' : result.status === 'broken' ? 'üî¥' : 'üü£';
                    devLog(`  ${index + 1}. ${statusEmoji} Pin ${result.pin_id}: ${result.status} (${result.url})`);
                });
            }
            
            processingState.healthCheckedPins += data.checked;
            
            const totalChecked = processingState.healthCheckedPins;
            const totalWithLinks = processingState.pinsWithLinks;
            const remainingUrls = totalWithLinks - totalChecked;
            
            devLog(`üìä Overall Progress: ${totalChecked}/${totalWithLinks} URLs checked`);
            
            if (remainingUrls <= 0) {
                // All URLs checked
                devLog('üéâ All URLs have been health checked!');
                devLog('‚úÖ Phase 3 complete: URL health checking finished');
                devLog('üéâ All processing phases complete! System is ready.');
                processingState.phase = 'complete';
                updateProcessingStatus();
            } else {
                // Continue checking more URLs
                devLog(`‚è≥ ${remainingUrls} URLs still need checking...`);
                devLog(`‚è≥ Continuing URL health checking in 1 second...`);
                setTimeout(startUrlHealthChecking, 1000);  // Reduced from 3 seconds to 1 second
            }
        } else {
            devError('‚ùå URL health check batch failed:', data.error);
            devError('‚ùå Stopping URL health checking due to error');
            processingState.phase = 'complete';
            updateProcessingStatus();
        }
    })
    .catch(error => {
        devError('‚ùå Network error during URL health checking:', error);
        devError('‚ùå Stopping URL health checking due to network error');
        processingState.phase = 'complete';
        updateProcessingStatus();
    });
}

function updateProcessingStatus() {
    const statusBtn = document.getElementById('processingStatusBtn');
    const statusText = document.getElementById('processingStatusText');
    
    switch (processingState.phase) {
        case 'idle':
            statusText.textContent = 'üé® Ready';
            break;
        case 'caching':
            // Count uncached pins dynamically from DOM
            const allPins = document.querySelectorAll('.pin-card');
            const uncachedPins = Array.from(allPins).filter(pin => {
                const imageUrl = pin.getAttribute('data-image-url');
                const hasCached = pin.getAttribute('data-has-cached') === 'true';
                return imageUrl && imageUrl.startsWith('http') && !hasCached;
            });
            const uncachedCount = uncachedPins.length;
            statusText.textContent = `üìÅ Caching ${uncachedCount} images...`;
            break;
        case 'extracting':
            // Count pins without colors dynamically from DOM
            const pinsWithoutColors = document.querySelectorAll('.pin-card[data-has-db-colors="false"]');
            const remaining = pinsWithoutColors.length;
            statusText.textContent = `üé® Extracting colors (${remaining} left)`;
            break;
        case 'health-checking':
            const uncheckedUrls = processingState.pinsWithLinks - processingState.healthCheckedPins;
            statusText.textContent = `üîó Checking ${uncheckedUrls} URLs...`;
            break;
        case 'complete':
            statusText.textContent = `‚úÖ All processing complete`;
            break;
    }
}

function getBoardId() {
    // Extract board ID from URL or data attribute
    const path = window.location.pathname;
    const match = path.match(/\/board\/(\d+)/);
    return match ? match[1] : null;
}


// Track currently active section filter
let activeSectionFilter = 'all';

// Section circle handling
function initializeSectionFiltering() {
    const sectionCircles = document.querySelectorAll('.section-circle');
    
    // Debug: Log all available section IDs
    const availableSections = Array.from(sectionCircles).map(c => ({
        id: c.dataset.sectionId,
        name: c.querySelector('.section-circle-name')?.textContent
    }));
    console.log('Available sections:', availableSections);
    
    // Debug: Log all pin section IDs currently in DOM - show actual values
    const allPins = document.querySelectorAll('.pin-card');
    const sectionIdCounts = {};
    allPins.forEach(pin => {
        const sid = pin.dataset.sectionId || 'undefined';
        sectionIdCounts[sid] = (sectionIdCounts[sid] || 0) + 1;
    });
    
    // Log in a more readable format
    console.log('üìä Pin section ID distribution:');
    Object.entries(sectionIdCounts).forEach(([sectionId, count]) => {
        const sectionName = availableSections.find(s => s.id === sectionId)?.name || (sectionId === 'all' ? 'Unassigned/All' : 'Unknown');
        console.log(`   - Section "${sectionId}" (${sectionName}): ${count} pins`);
    });
    
    sectionCircles.forEach(circle => {
        circle.addEventListener('click', async function() {
            // Remove active from all
            sectionCircles.forEach(btn => btn.classList.remove('active'));
            // Add active to clicked
            this.classList.add('active');
            
            const selectedSection = this.dataset.sectionId;
            activeSectionFilter = selectedSection;
            
            // Check if we have pins for this section already loaded
            const existingPins = document.querySelectorAll(`.pin-card[data-section-id="${selectedSection}"]`);
            
            if (selectedSection !== 'all' && existingPins.length === 0) {
                // No pins loaded for this section - fetch from API
                console.log(`üì• Fetching pins for section ${selectedSection}...`);
                await fetchSectionPins(selectedSection);
            }
            
            applyCurrentSectionFilter();
            
            // Scroll selected circle into view
            this.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        });
    });
}

// Track loaded sections to avoid duplicate fetches
const loadedSections = new Set(['all']);

// Fetch pins for a specific section
async function fetchSectionPins(sectionId) {
    if (loadedSections.has(sectionId)) {
        console.log(`Section ${sectionId} already loaded`);
        return;
    }
    
    const boardId = getBoardId();
    if (!boardId) return;
    
    try {
        const response = await fetch(`/api/board/${boardId}/pins?section_id=${sectionId}&limit=200&offset=0`);
        const data = await response.json();
        
        if (data.success && data.pins && data.pins.length > 0) {
            console.log(`üì• Loaded ${data.pins.length} pins for section ${sectionId}`);
            
            const pinsGrid = document.getElementById('pinsGrid');
            
            data.pins.forEach(pin => {
                // Check if pin already exists in DOM
                if (document.getElementById(`pin-${pin.id}`)) {
                    return; // Skip - already loaded
                }
                
                const pinCard = createBoardPinCard(pin);
                pinsGrid.appendChild(pinCard);
                
                // Pre-reserve space for the new pin
                preReserveImageSpace(pinCard);
            });
            
            loadedSections.add(sectionId);
        } else {
            console.log(`No pins found for section ${sectionId}`);
            loadedSections.add(sectionId); // Mark as loaded even if empty
        }
    } catch (error) {
        console.error(`Error fetching section ${sectionId} pins:`, error);
    }
}

// Apply the current section filter to all pins
function applyCurrentSectionFilter() {
    const items = document.querySelectorAll('.pin-card');
    
    let shownCount = 0;
    let hiddenCount = 0;
    
    items.forEach(item => {
        const pinSectionId = item.dataset.sectionId;
        // Compare as strings - both 'all' check and section ID match
        // Handle null/undefined section_id as 'all' or unassigned
        const shouldShow = activeSectionFilter === 'all' || 
                           pinSectionId === activeSectionFilter ||
                           String(pinSectionId) === String(activeSectionFilter);
        
        if (shouldShow) {
            item.style.display = '';  // Use empty string instead of 'block' to respect CSS
            shownCount++;
        } else {
            item.style.display = 'none';
            hiddenCount++;
        }
    });
    
    console.log(`Section filter "${activeSectionFilter}": shown=${shownCount}, hidden=${hiddenCount}`);
    
    // Show helpful message if no pins match the section
    if (shownCount === 0 && activeSectionFilter !== 'all') {
        // Check if we've already loaded this section
        const alreadyLoaded = loadedSections.has(activeSectionFilter);
        
        // Show a message in the grid
        const pinsGrid = document.getElementById('pinsGrid');
        let emptyMsg = document.getElementById('sectionEmptyMessage');
        if (!emptyMsg) {
            emptyMsg = document.createElement('div');
            emptyMsg.id = 'sectionEmptyMessage';
            emptyMsg.className = 'text-center py-12 text-gray-500';
            pinsGrid.insertBefore(emptyMsg, pinsGrid.firstChild);
        }
        
        if (alreadyLoaded) {
            console.warn(`‚ö†Ô∏è No pins are assigned to section "${activeSectionFilter}". Pins need to be moved to this section.`);
            emptyMsg.innerHTML = `
                <div class="text-4xl mb-4">üìÇ</div>
                <p class="text-lg font-medium">No pins in this section</p>
                <p class="text-sm mt-2">Move pins to this section from the pin detail page</p>
            `;
        } else {
            // Still loading
            emptyMsg.innerHTML = `
                <div class="text-4xl mb-4 animate-pulse">‚è≥</div>
                <p class="text-lg font-medium">Loading pins...</p>
            `;
        }
        emptyMsg.style.display = 'block';
    } else {
        // Hide the empty message
        const emptyMsg = document.getElementById('sectionEmptyMessage');
        if (emptyMsg) {
            emptyMsg.style.display = 'none';
        }
    }
}

// Board management buttons
function initializeBoardManagement() {
    // No special initialization needed for the new automatic system
}

// Handle pin highlighting from URL parameter
function handlePinHighlighting() {
    const urlParams = new URLSearchParams(window.location.search);
    const highlightPinId = urlParams.get('highlight');
    
    if (highlightPinId) {
        // Wait for images to load and layout to stabilize
        waitForLayoutStabilization(() => {
            const pinElement = document.getElementById(`pin-${highlightPinId}`);
            if (pinElement) {
                // First, ensure the pin element is in view (non-smooth to avoid layout shifts)
                const pinRect = pinElement.getBoundingClientRect();
                const pinOffset = pinRect.top + window.scrollY;
                
                // Scroll to position with a small offset to account for header
                window.scrollTo({
                    top: pinOffset - 100,
                    behavior: 'instant' // Use instant to avoid layout shifts during scroll
                });
                
                // Wait a bit for scroll to complete, then highlight
                setTimeout(() => {
                    // Scroll again smoothly to center it
                    pinElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center',
                        inline: 'nearest'
                    });
                    
                    // Add highlight class after scroll starts
                    setTimeout(() => {
                        pinElement.classList.add('highlighted');
                    }, 100);
                    
                    // Remove highlight class after animation completes
                    setTimeout(() => {
                        pinElement.classList.remove('highlighted');
                    }, 2100);
                    
                    // Clean up URL parameter
                    const newUrl = window.location.pathname;
                    window.history.replaceState({}, document.title, newUrl);
                }, 50);
            }
        });
    }
}

// Wait for layout to stabilize before scrolling
function waitForLayoutStabilization(callback) {
    // With pre-reserved space for images, we can proceed almost immediately
    // All heights are locked so the layout is stable
    
    const checkLayoutReady = () => {
        const pinsGrid = document.getElementById('pinsGrid');
        if (!pinsGrid) {
            setTimeout(checkLayoutReady, 20);
            return;
        }
        
        // Check if all containers have locked heights
        const lockedContainers = pinsGrid.querySelectorAll('.image-container[data-height-locked="true"]');
        const allContainers = pinsGrid.querySelectorAll('.image-container');
        
        // If most heights are locked (>80%), proceed immediately
        const lockRatio = allContainers.length > 0 ? lockedContainers.length / allContainers.length : 0;
        
        if (lockRatio >= 0.8 || lockedContainers.length > 0) {
            // Layout is stable because heights are locked - proceed immediately
            // Just one RAF to ensure paint is complete
            requestAnimationFrame(() => {
                callback();
            });
        } else {
            // No pre-reserved heights - fall back to waiting for images
            let lastHeight = 0;
            let stableCount = 0;
            const maxWaitTime = 1000; // Reduced from 1500ms
            const startTime = Date.now();
            
            const checkStability = () => {
                const currentHeight = pinsGrid.scrollHeight;
                const elapsed = Date.now() - startTime;
                
                if (currentHeight === lastHeight && currentHeight > 0) {
                    stableCount++;
                } else {
                    stableCount = 0;
                    lastHeight = currentHeight;
                }
                
                // If layout has been stable for 2 checks (200ms) or max time reached
                if (stableCount >= 2 || elapsed > maxWaitTime) {
                    callback();
                } else {
                    setTimeout(checkStability, 100);
                }
            };
            
            setTimeout(checkStability, 100);
        }
    };
    
    // Start checking immediately (space should already be pre-reserved)
    checkLayoutReady();
}

</script>
{% endblock %} 